#include "helper_map.hps"
#include "player_types.hps"

//-------------------------------------------------

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

//-------------------------------------------------

shared enum eMusicPrio
{
	eMusicPrio_BgAmb = 0, //Played as background for larger chunk of the level.
	eMusicPrio_SceneAmb = 1, //Played during a specifc scene
	eMusicPrio_MinorEvent = 2, //Eg Notice something weird. Never loop!
	eMusicPrio_AgentAmb = 3, //Used by AI code only!
	eMusicPrio_AgentToAmbTransition = 4, //Used by AI code only!
	eMusicPrio_BigEvent = 5,  //Eg find important character. Never loop!
	eMusicPrio_AgentAlert = 6, //Used by AI code only!
	eMusicPrio_AgentToAlertTransition = 7, //Used by AI code only!
	eMusicPrio_AgentHunt = 8, //Used by AI code only!
	eMusicPrio_AgentToHuntTransition = 9, //Used by AI code only!
	eMusicPrio_OverrideAll = 10, //Used when you want to override all AI code!
}

//-------------------------------------------------

/////////////////////////////////////////
// GENERAL SOUND
/////////////////////////////////////////

//-------------------------------------------------

int[] _gvSoundGlobalEntryType = {	eSoundEntryType_World, eSoundEntryType_WorldClean, 
									eSoundEntryType_GuiWorld, eSoundEntryType_Gui};

int [] _gvSoundGlobalFreqType = {	eLuxGlobalFreqType_ScriptWorld, eLuxGlobalFreqType_ScriptWorldClean,
									eLuxGlobalFreqType_ScriptGuiWorld, eLuxGlobalFreqType_ScriptGui};

int [] _gvSoundGlobalVolumeType = {	eLuxGlobalVolumeType_ScriptWorld, eLuxGlobalVolumeType_ScriptWorldClean,
									eLuxGlobalVolumeType_ScriptGuiWorld, eLuxGlobalVolumeType_ScriptGui};

int _glSoundGlobalNum=4;

bool _Sound_Global_EntryAffected(int alIdx, eSoundEntryType aAffectedTypes)
{
	return (aAffectedTypes & _gvSoundGlobalEntryType[alIdx])!=0;
}
//-------------------------------------------------

/**
 * Sets the relative frequency of all sounds.
 * 
 * @param afFreq, the relative frequency to use. 1= normal, 2=doubled, 0.5=half as fast, etc
 * @param aAffectedTypes, The kind of sounds affected, possible values: eSoundEntryType_World, eSoundEntryType_WorldClean, eSoundEntryType_WorldAll, eSoundEntryType_Gui or eSoundEntryType_All
 **/
void Sound_SetGlobalSpeed(float afFreq, eSoundEntryType aAffectedTypes = eSoundEntryType_WorldAll)
{
	for(int i=0; i<_glSoundGlobalNum; ++i)
	{
		if(_Sound_Global_EntryAffected(i, aAffectedTypes))
			cSound_SetGlobalSpeed(afFreq, _gvSoundGlobalEntryType[i], _gvSoundGlobalFreqType[i]);
	}
}

//-------------------------------------------------

/**
 * Fade the relative frequency of all sounds.
 * 
 * @param afFreq, the relative frequency to use. 1= normal, 2=doubled, 0.5=half as fast, etc
 * @param afTime, the time which the fade takes
 * @param aAffectedTypes, The kind of sounds affected, possible values: eSoundEntryType_World, eSoundEntryType_WorldClean, eSoundEntryType_WorldAll, eSoundEntryType_Gui or eSoundEntryType_All
 **/
void Sound_FadeGlobalSpeed(float afFreq, float afTime, eSoundEntryType aAffectedTypes = eSoundEntryType_WorldAll)
{
	for(int i=0; i<_glSoundGlobalNum; ++i)
	{
		if(_Sound_Global_EntryAffected(i, aAffectedTypes))
		{
			float fCurrent = cSound_GetGlobalSpeedFromId(_gvSoundGlobalFreqType[i]);
			float fDist = cMath_Abs(afFreq - fCurrent);
			if(cMath_Abs(fDist) <0.0001f) continue;
			float fSpeed = afTime<=0 ? 1000.0f : fDist / afTime;
			
			cSound_FadeGlobalSpeed(afFreq, fSpeed, _gvSoundGlobalEntryType[i], _gvSoundGlobalFreqType[i],false);
		}
	}
}

//-------------------------------------------------

/**
 * Set the relative volume of all sounds.
 * 
 * @param afVolume, the relative volume to use. possible values: 0 - 1
 * @param aAffectedTypes, The kind of sounds affected, possible values: eSoundEntryType_World, eSoundEntryType_WorldClean, eSoundEntryType_WorldAll, eSoundEntryType_Gui or eSoundEntryType_All
 **/
void Sound_SetGlobalVolume(float afVolume, eSoundEntryType aAffectedTypes = eSoundEntryType_WorldAll)
{
	for(int i=0; i<_glSoundGlobalNum; ++i)
	{
		if(_Sound_Global_EntryAffected(i, aAffectedTypes))
			cSound_SetGlobalVolume(afVolume, _gvSoundGlobalEntryType[i], _gvSoundGlobalVolumeType[i]);
	}	
}

//-------------------------------------------------

/**
 * Fade the relative volume of all sounds.
 * 
 * @param afVolume, the relative volume to use. possible values: 0 - 1
 * @param afTime, the time which the fade takes
 * @param aAffectedTypes, The kind of sounds affected, possible values: eSoundEntryType_World, eSoundEntryType_WorldClean, eSoundEntryType_WorldAll, eSoundEntryType_Gui, , eSoundEntryType_GuiWorld or eSoundEntryType_All
 **/
void Sound_FadeGlobalVolume(float afVolume, float afTime, eSoundEntryType aAffectedTypes = eSoundEntryType_WorldAll)
{
	for(int i=0; i<_glSoundGlobalNum; ++i)
	{
		if(_Sound_Global_EntryAffected(i, aAffectedTypes))
		{
			float fCurrent = cSound_GetGlobalVolumeFromId(_gvSoundGlobalVolumeType[i]);
			float fDist = afVolume - fCurrent;
			if(cMath_Abs(fDist) <0.0001f) return;
			
			float fSpeed = afTime<=0 ? 1000.0f : fDist / afTime;
			
			cSound_FadeGlobalVolume(afVolume, fSpeed, _gvSoundGlobalEntryType[i], _gvSoundGlobalVolumeType[i],false);
		}
	}
}

//-------------------------------------------------

/**
 * Creates an event that is heard by any entity with the Listener component
 * 
 * @param asEntity, Name of the entity to create it at. Wildcardds (*) possible.
 * @param afRadius, How big the event's sphere of influence will be.
 * @param alPrio, The prio of the event. Some listener sort out certain prios. 
 **/
void Sound_CreateAIEventAtEntity(const tString&in asEntity, float afRadius, int alPrio)
{
	/////////////////////////////////////////
	// Get all entities
	array<iLuxEntity@> vEntities;
	cLux_GetCurrentMap().GetEntityArray(asEntity, eLuxEntityType_LastEnum, "", vEntities);
	if(vEntities.length() == 0)
	{
		Error("Could not find any entities with name '"+asEntity+"' for Sound_BroadcastSoundHeardEvent");
		return ;
	}
		
	/////////////////////////////
	// Iterate Parents
	for(uint i=0; i<vEntities.length(); ++i)
	{
		iLuxEntity@ pEntity = vEntities[i];
		
		cLux_GetCurrentMap().BroadcastSoundHeardEvent("ScriptedEvent", pEntity.GetPosition(), afRadius, alPrio); 
	}
}

//-------------------------------------------------

/////////////////////////////////////////
// SOUNDS
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Create and play a sound (.snt) file at the position of an entity or player.
 * 
 * @param tString asSoundName, name of the sound that is used when you like to, for example, stop it.
 * @param tString asSoundFile, name of the FMOD event or .snt sound file to play. FMOD always needs to be full path ie "project/event_group(s)/event".
 * @param tString asEntity, name of the entity to play the sound at, can also be "player".
 * @param float afFadeTime, fade in the sound during this many seconds, 0 = no fade.
 * @param bool abSaveSound, if the sound should be saved, ie if sound loops and the sound should play on exit and enter of the level.
 * @param float afTargetVolume, the volume (0.0 - 1.0) the sound should be played at. Defaults to 1.0f.
 * @param float afCustomMinDist, min dist of the sound. If -1 default will be used.
 * @param float afCustomMaxDist, max dist of the sound. If -1 default will be used
 **/
void Sound_CreateAtEntity(const tString &in asSoundName, const tString &in asSoundFile, const tString &in asEntity, 
						  float afFadeTime = 0.0f, bool abSaveSound = false, float afTargetVolume=1.0f, float afCustomMinDist=-1.f, float afCustomMaxDist=-1.f)
{
	float fFadeSpeed = afFadeTime ==0 ? 0 : afTargetVolume/afFadeTime;

	bool bRemoveWhenOver = true;
	
	//////////////////////////
	// Player
	if(cString_ToLowerCase(asEntity) == "player")
	{
		cLuxMap@ pMap = cLux_GetCurrentMap();
		if(pMap is null) return;

		cSoundEntity@ pSound = pMap.GetWorld().CreateSoundEntity(asSoundName, asSoundFile, bRemoveWhenOver);
		
		if(pSound !is null)
		{
			Map_GetEntity("Camera").GetAttachEntity().AddChild(pSound);

			pSound.SetScriptableIsSaved(abSaveSound);
			pSound.FadeIn(fFadeSpeed, afTargetVolume);
		}
	}
	
	//////////////////////////
	// Normal entity
	else
	{
		iLuxEntity@ pEntity = cLux_GetCurrentMap().GetEntityByName(asEntity, eLuxEntityType_LastEnum, "");
		if(pEntity is null)
		{
			Error("Cannot find entity '"+asEntity+"' and play sound '"+asSoundFile+"' at it\n");
			return;
		}

		cSoundEntity@ pSound = cLux_GetCurrentMap().GetWorld().CreateSoundEntity(asSoundName, asSoundFile, bRemoveWhenOver);
		if(pSound is null)
		{
			Error("Cannot find sound '"+asSoundFile+"' and play at entity "+asEntity+"\n");
			return;
		}
		
		if(abSaveSound==false)
		{
			pEntity.GetAttachEntity().AddChild(pSound);
		}
		else
		{
			pSound.SetPosition(pEntity.GetAttachEntity().GetWorldPosition());
		}
		
		//cLux_AddDebugMessage("Creating sound "+asSoundFile+" at "+asEntity+" pos:"+pSound.GetWorldPosition(), false);
		
		if (afCustomMinDist != -1.f)
		{
			pSound.SetUseCustomProperties(true);
			pSound.SetCustomMinDistance(afCustomMinDist);
		}
		
		if (afCustomMaxDist != -1.f)
		{
			pSound.SetUseCustomProperties(true);
			pSound.SetCustomMaxDistance(afCustomMaxDist);
		}
				
		pSound.SetScriptableIsSaved(abSaveSound);
		pSound.FadeIn(fFadeSpeed, afTargetVolume);
	}
}

//-------------------------------------------------

/**
 * Create and play a sound (.snt) file at the position of an entity or player. 
 * If a Soundscape area SoundPrefix is set, then that will be used as a parent folder for the sound.
 * 
 * @param tString asSoundName, name of the sound that is used when you like to, for example, stop it.
 * @param tString asSoundFile, name of the FMOD event or .snt sound file to play. FMOD always needs to be full path ie "project/event_group(s)/event". If the prefix is not "", then the path is "project/event_group(s)/prefix/event".
 * @param tString asEntity, name of the entity to play the sound at, can also be "player".
 * @param float afFadeTime, fade in the sound during this many seconds, 0 = no fade.
 * @param bool abSaveSound, if the sound should be saved, ie if sound loops and the sound should play on exit and enter of the level.
 * @param float afTargetVolume, the volume (0.0 - 1.0) the sound should be played at. Defaults to 1.0f.
 **/
void Sound_CreateAtEntity_UsePrefix(const tString &in asSoundName, const tString &in asSoundFile, const tString &in asEntity, 
						  float afFadeTime, bool abSaveSound, float afTargetVolume=1.0f)
{
	tString sPrefix = cLux_GetSoundscapeHandler().GetCurrentSoundPrefix();
	tString sFinalFile = asSoundFile;
	if(sPrefix != "")
	{
		//tString sPath = cString_GetFilePath(asSoundFile);
		//tString sFile =  cString_GetFileName(asSoundFile);
		int lPos = cString_GetLastCharPos(asSoundFile, '/');
		if(lPos >= 0) 	
		{
			tString sPath = cString_Sub(asSoundFile,0, lPos+1);
			tString sFile = cString_Sub(asSoundFile,lPos+1);
			sFinalFile = sPath + sPrefix+"/"+sFile;
		}
		
	}
	
	Sound_CreateAtEntity(asSoundName, sFinalFile, asEntity, afFadeTime, abSaveSound, afTargetVolume);
}
//-------------------------------------------------

/**
 * Play a sound that exists in the level editor, attached to an entity, or previously created that 
 * has been stopped and now should be played again.
 * 
 * @param tString asSoundName, name of the sounds that you would like to play. Wildcard(s) * are supported.
 * @param float afFadeTime, fade in the sound during this many seconds, 0 = no fade.
 * @param bool abResetVolMul, reset the FadeVolumeMul set when using Sound_Fade.
 **/
void Sound_Play(const tString &in asSoundName, float afFadeTime, bool abResetVolMul = false)
{
	cLuxMap@ pMap = cLux_GetCurrentMap();
	if(pMap is null) return;

	float fFadeSpeed = afFadeTime == 0 ? 0 : 1.0f/afFadeTime;
	
	array<cSoundEntity@> vSoundEntities;
	Map_GetSoundEntityArray(asSoundName, vSoundEntities);
	
	if(vSoundEntities.length() == 0)
	{
		Error("Could not find sound entity "+asSoundName+" in Sound_Play");
		return;
	}
		
	for(uint i=0; i<vSoundEntities.length(); ++i)
	{
		cSoundEntity@ pSoundEntity = vSoundEntities[i];
		
		if(fFadeSpeed <= 0)	pSoundEntity.Play();
		else				pSoundEntity.FadeIn(fFadeSpeed);
		
		if(abResetVolMul) pSoundEntity.FadeVolumeMul(1, 0);
	}	
}

//-------------------------------------------------

/**
 * Stop a sound that is currently playing. Can be sound entities or Gui sounds.
 * 
 * @param tString asSoundName, name of the sound that you would like to stop. Wildcard(s) * are supported.
 * @param float afFadeTime, fade out the sound during this many seconds, 0 = no fade. Must be 0 if using a FMOD sound event with Sustain Point.
 **/
void Sound_Stop(const tString &in asSoundName, float afFadeTime)
{
	cLuxMap@ pMap = cLux_GetCurrentMap();
	if(pMap is null) return;

	float fFadeSpeed = afFadeTime == 0 ? 0 : 1.0f/afFadeTime;
	
	array<cSoundEntity@> vSoundEntities;
	Map_GetSoundEntityArray(asSoundName, vSoundEntities);
	
	if(vSoundEntities.length() == 0)
	{
		Error("Could not find sound entity "+asSoundName+" in Sound_Stop");
		return;
	}
		
	for(uint i=0; i<vSoundEntities.length(); ++i)
	{
		cSoundEntity@ pSoundEntity = vSoundEntities[i];
		
		if(fFadeSpeed <= 0)	pSoundEntity.Stop(true);
		else				pSoundEntity.FadeOut(fFadeSpeed);
	}
}

//-------------------------------------------------

/**
 * Fade/Change the volume of a sound entity.
 * 
 * @param asSoundName, the sound file to fade. Wildcard(s) * are supported.
 * @param afVolumeDest, at what relative volume to fade the sound to. 1 = default volume of entity, can't go over 1. 
 * @param afFadeTime, how long in seconds the fade should take.
 **/
void Sound_Fade(const tString &in asSoundName, float afVolumeDest, float afFadeTime)
{
	cLuxMap@ pMap = cLux_GetCurrentMap();
	if(pMap is null) return;

	float fFadeSpeed = afFadeTime == 0 ? 0 : 1.0f/afFadeTime;

	array<cSoundEntity@> vSoundEntities;
	Map_GetSoundEntityArray(asSoundName, vSoundEntities);
	
	if(vSoundEntities.length() == 0)
	{
		Error("Could not find sound entity "+asSoundName+" in Sound_Fade");
		return;
	}
		
	for(uint i=0; i<vSoundEntities.length(); ++i)
	{
		cSoundEntity@ pSoundEntity = vSoundEntities[i];
		
		if(pSoundEntity.IsStopped())
			pSoundEntity.FadeIn(fFadeSpeed);

		pSoundEntity.FadeVolumeMul(afVolumeDest, fFadeSpeed);
	}
		
}

//-------------------------------------------------

/**
 * Play a sound without any world position, either .snt files or any of the supported 
 * formats (.wav, .ogg etc) without the need of a .snt file.
 * 
 * @param tString asSoundFile, the sound file to play.
 * @param float afVolume, at what volume to play the sound. 
 * @param eSoundEntryType aEntryType, the entry type of the sound.
 **/
void Sound_PlayGui(const tString &in asSoundFile, float afVolume, eSoundEntryType aEntryType =  eSoundEntryType_Gui)
{
	tString sExt = cString_GetFileExt(asSoundFile);

	//Sound entity!
	if(sExt == "" || sExt == "snt")
	{
		cLux_PlayGuiSoundData(asSoundFile, aEntryType, afVolume, true);
	}
	//Normal sound
	else
	{
		cSound_PlayGui(asSoundFile, false, afVolume, cVector3f(0,0,0), aEntryType);
	}
}

//-------------------------------------------------

/**
 * Fades in a GUI sound. This is can called directly after Sound_PlayGui or in case the sound doesn't exist, start it.
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param afVolume, volume to fade in to.
 * @param float afFadeTime, Time it takes to fade it out
 **/
void Sound_FadeInGui(const tString &in asSoundFile, float afVolume, float afFadeTime)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Sound_PlayGui(asSoundFile, 1.0f);
		
		@pEntry = cSound_GetEntry(asSoundFile);
		if(pEntry is null)
		{
			Error("Couldn't play sound '"+asSoundFile+"' for Sound_FadeInGui");
			return;
		}
	}
	
	if(afFadeTime<=0) return;
	
	pEntry.FadeIn(afVolume, afVolume/afFadeTime);
}

//-------------------------------------------------

/**
 * Stops a GUI sounds
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param float afFadeTime, Time it takes to fade it out
 * @param bool abPlayEnd, If the end (setup in the event) should be played. Only applicable is afFadeTime is 0
 **/
void Sound_StopGui(const tString &in asSoundFile, float afFadeTime, bool abPlayEnd=true)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Error("Couldn't find sound entry '"+asSoundFile+"' for Sound_StopGui");
		return;
	}
	
	if(afFadeTime<=0 || pEntry.GetVolumeMul()<=0)
		pEntry.Stop(abPlayEnd);
	else
		pEntry.FadeOut(pEntry.GetVolumeMul() / afFadeTime);
}

//-------------------------------------------------

/**
 * Fades a GUI sound volume to another
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param float afVolumeDest, The new volume (note, if 0 it will not stop!)
 * @param bool afFadeTime, Time the fade takes
 **/
void Sound_FadeGuiVolume(const tString &in asSoundFile, float afVolumeDest, float afFadeTime)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Error("Couldn't find sound entry '"+asSoundFile+"' for Sound_FadeGuiVolume");
		return;
	}
	
	float fVolMul = pEntry.GetVolumeMul();
	
	if(afFadeTime<=0)
		pEntry.SetVolumeMul(afVolumeDest);
	else
		pEntry.FadeVolumeMulTo(afVolumeDest, cMath_Abs(fVolMul-afVolumeDest)/afFadeTime);
}

//-------------------------------------------------

/**
 * Fades a GUI sound speed to another
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param float afSpeedDest, The new speed (note, if 0 it will not stop!)
 * @param bool afFadeTime, Time the fade takes
 **/
void Sound_FadeGuiSpeed(const tString &in asSoundFile, float afSpeedDest, float afFadeTime)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Error("Couldn't find sound entry '"+asSoundFile+"' for Sound_FadeGuiSpeed");
		return;
	}
	
	float fVolMul = pEntry.GetVolumeMul();
	
	if(afFadeTime<=0)
		pEntry.SetSpeedMul(afSpeedDest);
	else
		pEntry.FadeSpeedMulTo(afSpeedDest, cMath_Abs(fVolMul-afSpeedDest)/afFadeTime);
}

//-------------------------------------------------

/**
 * Sets the param of a gui sound
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param asParam, The param variable name
 * @param afValue, The new value to give it.
 **/
void Sound_SetGuiParam(const tString &in asSoundFile, const tString& in asParam, float afValue)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Error("Couldn't find sound entry '"+asSoundFile+"' for Sound_SetGuiParam");
		return;
	}
	
	pEntry.SetParam(asParam, afValue);
}


//-------------------------------------------------

/**
 * Sets the param of a gui sound
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 * @param alParam, The param index
 * @param afValue, The new value to give it.
 **/
void Sound_SetGuiParam(const tString &in asSoundFile, int alParam, float afValue)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	if(pEntry is null)
	{
		Error("Couldn't find sound entry '"+asSoundFile+"' for Sound_SetGuiParam");
		return;
	}
	
	pEntry.SetParam(alParam, afValue);
}

//-------------------------------------------------


/**
 * Checks if a gui sound is playing.
 * 
 * @param tString asSoundFile, the sound file for the sound that is playing
 **/
bool Sound_GuiIsPlaying(const tString &in asSoundFile)
{
	cSoundEntry@ pEntry = cSound_GetEntry(asSoundFile);
	return pEntry !is null;
}

//-------------------------------------------------

/**
 * Preloads a specific of sound event
 * Preloading removes lag spikes that can occur when loading a sound from the hdd
 * 
 * @param asInternalPath, path of the sound eg. "physics/metal/hit"
 **/
void Sound_PreloadEvent(const tString&in asInternalPath)
{
	cSound_PreloadSoundEvent(asInternalPath);
}

//-------------------------------------------------

/**
 * Preloads a group of sounds and its subgroups if selected
 * Preloading removes lag spikes that can occur when loading a sound from the hdd
 * 
 * @param asInternalPath, path of the sound eg. "physics/metal"
 * @param abSubGroups, if the subgroups should be loaded
 **/
void Sound_PreloadGroup(const tString&in asInternalPath, bool abSubGroups)
{
	cSound_PreloadGroup(asInternalPath, true, abSubGroups);
}

//-------------------------------------------------

/**
 * Preloads a whole sound project and all sounds within it
 * Preloading removes lag spikes that can occur when loading a sound from the hdd
 * 
 * @param asName, name of the sound project file
 **/
void Sound_PreloadProject(const tString&in asName)
{
	cSound_PreloadProject(asName, true);
}

//-------------------------------------------------

/**
 * Preloads all the basic sounds
 * 
 **/
void Sound_PreloadCoreSounds()
{
	Sound_PreloadProject("Physics");
	Sound_PreloadGroup("Player/footsteps/default", true);
	Sound_PreloadGroup("Player/crawl/default", true);
	Sound_PreloadGroup("Player/ladder/rope", true);
	Sound_PreloadGroup("Player/UI", true);
	Sound_PreloadGroup("Player/ladder", true);
	Sound_PreloadGroup("NPC_Creatures", true);
}

void Sound_PreloadCoreUWSounds()
{
	Sound_PreloadProject("Physics");
	Sound_PreloadGroup("Player/footsteps/default_underwater", true);
	Sound_PreloadGroup("Player/breaths", true);
	Sound_PreloadGroup("Player/ladder/metal_underwater", true);
	Sound_PreloadGroup("Player/landing/underwater", true);
	Sound_PreloadGroup("Player/foley", true);
	Sound_PreloadGroup("Player/UI", true);
	Sound_PreloadGroup("NPC_Creatures/", true);
}

void Sound_PreloadCoreInteractions()
{
	Sound_PreloadGroup("Entities_Station/", true);
}

void Sound_PreloadCoreUWInteractions()
{
	Sound_PreloadGroup("Entities_OceanBottom", true);
	Sound_PreloadGroup("shipwreck", true);
	Sound_PreloadGroup("Entities_Station/tech/terminal_beeps/pathOS_underwater_comp", true);
}

void Sound_PreloadGhost()
{
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/appear");
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/body_sound");
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/disappear");
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/phase/start");
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/phase/loop");
	Sound_PreloadEvent("creatures/foley/creature/tin_hinan/phase/end");
}

//-------------------------------------------------

/**
 * Returns true or false if a given sound entity exists
 * 
 * @param asSoundName, name of the sound entity. Can contain wildcards.
 
 **/
bool Sound_Exists(const tString &in asSoundName)
{
	array<cSoundEntity@> vSounds;
	Map_GetSoundEntityArray(asSoundName, vSounds);
	
	return (vSounds.length() > 0);
}

//-------------------------------------------------

/**
 * Sets the sound's parameter with the specified id to a value.
 * 
 * @param asSoundName, name of the sound entity.
 * @param alParamId, the id of the parameter.
 * @param afValue, the value to set the param to.
 
 **/
void Sound_SetParam(const tString &in asSoundName, int alParamId, float afValue)
{
	cLuxMap@ pMap = cLux_GetCurrentMap();
	if(pMap is null) return;
	
	cSoundEntity@ pSoundEntity = pMap.GetWorld().GetSoundEntity(asSoundName);
	if(pSoundEntity is null)
	{
		Error("Couldn't find sound entity '" + asSoundName + "' for Sound_SetParam");
		return;
	}
	pSoundEntity.SetParam(alParamId, afValue);
}

//-------------------------------------------------

/**
 * Sets the sound's parameter with the specified id to a value.
 * 
 * @param asSoundName, name of the sound entity.
 * @param asParamName, the name of the parameter.
 * @param afValue, the value to set the param to.
 
 **/
void Sound_SetParam(const tString &in asSoundName, const tString &in asParamName, float afValue)
{
	cLuxMap@ pMap = cLux_GetCurrentMap();
	if(pMap is null) return;
	
	cSoundEntity@ pSoundEntity = pMap.GetWorld().GetSoundEntity(asSoundName);
	if(pSoundEntity is null)
	{
		Error("Couldn't find sound entity '" + asSoundName + "' for Sound_SetParam");
		return;
	}
	pSoundEntity.SetParam(asParamName, afValue);
}

//-------------------------------------------------

/**
 * Displays a closed caption for anyone with CC enabled.
 * 
 * @param asCategory, lang category for the text to display.
 * @param asEntry, lang entry for the text to display.
 * @param afTime, how long to display the text for. -1 = default setting (around 2 seconds)
 
 **/
void Sound_AddClosedCaption(const tString &in asCategory, const tString &in asEntry, float afTime=-1, bool abPositional=false, const cVector3f&in avPosition=cVector3f_Zero, bool abPlayWhenPaused=false)
{
	tWString sText = cLux_Translate(asCategory, asEntry);
	cLux_GetVoiceHandler().AddClosedCaption(sText, afTime >= 0 ? afTime : 2.25f, abPositional, avPosition, abPlayWhenPaused);
}

//-------------------------------------------------

/////////////////////////////////////////
// MUSIC
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Play music with extended options.
 * 
 * @param tString asFile, name (opt: path) of the music file to play.
 * @param bool abLoop, if the music should loop when it reaches the end.
 * @param float afVolume, at what volume to play the music at (0.0 - 1.0).
 * @param float afFreq, at what frequency to play the music, 1 = standard freq.
 * @param float afVolumeFadeTime, how many seconds to fade in the music, 0 = no fade.
 * @param float afFreqFadeTime, how many seconds to fade in the frequence change.
 * @param eMusicPrio alPrio, priority of the music track. A higher priority will stop a lower priority track.
 * @param bool abResume, if the music should be resumed if it is stopped and played again.
 **/
void Music_PlayExt(const tString &in asFile, bool abLoop, float afVolume, float afFreq, float afVolumeFadeTime, float afFreqFadeTime, eMusicPrio alPrio, bool abResume)
{
	cLux_GetMusicHandler().Play(asFile, abLoop, afVolume, afFreq, afVolumeFadeTime, afFreqFadeTime, alPrio,abResume, false);
}

//-------------------------------------------------

/**
 * Play music with extended options. SAVES THE SONG NAME IN A GLOBAL VARIABLE CALLED "music_to_play"
 * 
 * @param tString asFile, name (opt: path) of the music file to play.
 * @param bool abLoop, if the music should loop when it reaches the end.
 * @param float afVolume, at what volume to play the music at (0.0 - 1.0).
 * @param float afFreq, at what frequency to play the music, 1 = standard freq.
 * @param float afVolumeFadeTime, how many seconds to fade in the music, 0 = no fade.
 * @param float afFreqFadeTime, how many seconds to fade in the frequence change.
 * @param eMusicPrio alPrio, priority of the music track. A higher priority will stop a lower priority track.
 * @param bool abResume, if the music should be resumed if it is stopped and played again.
 **/
void Music_PlayExt_Save(const tString &in asFile, bool abLoop, float afVolume, float afFreq, float afVolumeFadeTime, float afFreqFadeTime, eMusicPrio alPrio, bool abResume)
{
	cLux_GetMusicHandler().Play(asFile, abLoop, afVolume, afFreq, afVolumeFadeTime, afFreqFadeTime, alPrio,abResume, false);
	//DoctorD edit: store the song name and volume in global variable
	cScript_SetGlobalVarString("music_to_play", asFile);
    cScript_SetGlobalVarFloat("music_to_play_volume", afVolume);
}

//-------------------------------------------------

/**
 * Play music at standard frequency with a default fade time of 0.3 seconds.
 * 
 * @param tString asFile, name (opt: path) of the music file to play.
 * @param float afVolume, at what volume to play the music at (0.0 - 1.0).
 * @param bool abLoop, if the music should loop when it reaches the end.
 * @param eMusicPrio alPrio, priority of the music track. A higher priority will stop a lower priority track.
 **/
void Music_Play(const tString&in asFile, float afVolume, bool abLoop, eMusicPrio alPrio)
{
	cLux_GetMusicHandler().Play(asFile, abLoop, afVolume, 1.0f, 0.3f, 1.0f, alPrio,true, false);
}

//-------------------------------------------------

/**
 * Play music at standard frequency with a default fade time of 0.3 seconds. SAVES THE SONG NAME IN A GLOBAL VARIABLE CALLED "music_to_play"
 * 
 * @param tString asFile, name (opt: path) of the music file to play.
 * @param float afVolume, at what volume to play the music at (0.0 - 1.0).
 * @param bool abLoop, if the music should loop when it reaches the end.
 * @param eMusicPrio alPrio, priority of the music track. A higher priority will stop a lower priority track.
 **/
void Music_Play_Save(const tString&in asFile, float afVolume, bool abLoop, eMusicPrio alPrio)
{
	cLux_GetMusicHandler().Play(asFile, abLoop, afVolume, 1.0f, 0.3f, 1.0f, alPrio,true, false);
	//DoctorD edit: store the song name and volume in global variable
	cScript_SetGlobalVarString("music_to_play", asFile);
    cScript_SetGlobalVarFloat("music_to_play_volume", afVolume);
}

//-------------------------------------------------

bool Music_IsSongPlaying(const tString&in asFile)
{
	return cLux_GetMusicHandler().IsSongPlaying(asFile);
}

//-------------------------------------------------

/**
 * Plays a piece of music over the currently running music
 * TODO: Needs to have proper code!
 * 
 * @param tString asFile, name (opt: path) of the music file to play.
 * @param float afVolume, at what volume to play the music at (0.0 - 1.0).
 **/
void Music_PlayOverlay(const tString&in asFile, float afVolume)
{
	cSound_PlayGuiStream(asFile, false, afVolume, cVector3f(0,0,0), eSoundEntryType_Gui);
}

//-------------------------------------------------

/**
 * Stop a music track for a certain priority from playing.
 * 
 * @param float afFadeTime, how many seconds it takes to fade the volume to 0.
 * @param eMusicPrio alPrio, priority of the music track that should be stopped.
 **/
void Music_Stop(float afFadeTime, eMusicPrio alPrio)
{
	cLux_GetMusicHandler().Stop(afFadeTime, alPrio);
}

//-------------------------------------------------

/**
 * Stop a music tracks for all priorities
 * 
 * @param float afFadeTime, how many seconds it takes to fade the volume to 0.
 **/
void Music_StopAll(float afFadeTime)
{
	for(int i=0; i<=eMusicPrio_OverrideAll;++i)
		cLux_GetMusicHandler().Stop(afFadeTime, i);
}

//-------------------------------------------------

/**
 * This adds music that is meant to only be played during a certain occurance, eg when an creature is hunting the player. 
 * 
 * @param a_idEntity Id of the entity that cause the occurance to happen
 * @param alTrackPrio, priority of this track instnace, in case there are many. If two tracks have the same prio, music prio is compared.
 * @param alMusicPrio, The prio of the music to be played.
 * @param asFile, File of the music to play.
 * @param afVolume, volume of the music to play
 * @param afFadeInTime, time it takes for the music to fade in
 * @param afFadeInTime, time it takes for the music to fade out. Not used if there is a swithc to another dynamic track.
 **/
//-----------------------------------------------------------------------
void Music_AddDynamicTrack(tID a_idEntity, int alTrackPrio, eMusicPrio alMusicPrio, const tString&in asFile, float afVolume, float afFadeInTime, float afFadeOutTime)
{
	cLux_GetMusicHandler().AddDynamicTrack(a_idEntity, alTrackPrio, alMusicPrio, asFile, afVolume, afFadeInTime, afFadeOutTime);
}

//-------------------------------------------------

/**
 * This removes the dynamic track for certain entity and, if playing, fades out the music associated with it.
 * 
 * @param a_idEntity, Id of the entity that cause the occurance to happen
 **/
void Music_RemoveDynamicTrack(tID a_idEntity)
{
	cLux_GetMusicHandler().RemoveDynamicTrack(a_idEntity);
}

//-------------------------------------------------

/**
 * Fades the volume multiplier for music.
 * 
 * @param afMul, target volume multiplier. Default is 1.
 * @param afTime, time to fade to the target multiplier.
 **/
void Music_FadeVolumeMul(float afMul, float afTime)
{
	float fCurrent = cSound_GetMusicVolumeMul();
	float fDist = afMul-fCurrent;
	if(cMath_Abs(fDist) <0.0001f) return;
	
	float fSpeed = afTime<=0 ? 1000.0f : fDist / afTime;
	
	cSound_FadeMusicVolumeMul(afMul, cMath_Abs(fSpeed));
}

//-------------------------------------------------

/////////////////////////////////////////
// VOICES
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Starts playing a voice
 * 
 * @param asSubject The name of the subject to play.
 * @param alSpecificLineIdx, if 0 or higher then a specific line index will be played. Set as -1 to play as stated in the data.
 * @param asCallback, called when subject is done playing. Syntax: void Func(const tString&in asScene, const tString&in asSubject)
 * @param alPrio, The priority of the voice, if higher than the currently playing, the current gets stopped and replaced, else this voice is not played.
 **/
bool Voice_Play(const tString&in asSubject, int alSpecificLineIdx=-1, const tString&in asCallback="", int alPrio=0)
{
	return cLux_GetVoiceHandler().Play(asSubject, alSpecificLineIdx, asCallback, alPrio, false);
}

//-------------------------------------------------

/**
 * Starts playing a voice that will play even if the game is paused
 * 
 * @param asSubject The name of the subject to play.
 * @param alSpecificLineIdx, if 0 or higher then a specific line index will be played. Set as -1 to play as stated in the data.
 * @param asCallback, called when subject is done playing. Syntax: void Func(const tString&in asScene, const tString&in asSubject)
 * @param alPrio, The priority of the voice, if higher than the currently playing, the current gets stopped and replaced, else this voice is not played.
 **/
bool Voice_PlayWhilePaused(const tString&in asSubject, int alSpecificLineIdx=-1, const tString&in asCallback="", int alPrio=0)
{
	return cLux_GetVoiceHandler().Play(asSubject, alSpecificLineIdx, asCallback, alPrio, true);
}
//-------------------------------------------------

/**
 * Starts playing a voice
 * 
 * @param asSubject The name of the subject to play.
 * @param afDelay How long before the voice should play.
 * @param alSpecificLineIdx, if 0 or higher then a specific line index will be played. Set as -1 to play as stated in the data.
 * @param asCallback, called when subject is done playing. Syntax: void Func(const tString&in asScene, const tString&in asSubject)
 * @param alPrio, The priority of the voice, if higher than the currently playing, the current gets stopped and replaced, else this voice is not played.
 **/
void Voice_PlayDelayed(const tString&in asSubject, float afDelay, int alSpecificLineIdx=-1, const tString&in asCallback="", int alPrio=0)
{
	tString sName = "_VoicePlayDelayed_" + asSubject;
	cScript_SetGlobalVarString(sName + "_Subject", asSubject);
	cScript_SetGlobalVarInt(sName + "_SpecificLineIdx", alSpecificLineIdx);
	cScript_SetGlobalVarString(sName + "_Callback", asCallback);
	cScript_SetGlobalVarInt(sName + "_Prio", alPrio);
	
	Map_AddTimer(sName, afDelay, "$_Voice_PlayDelayed_Timer");
}

void _Voice_PlayDelayed_Timer(const tString&in asTimer)
{
	cLux_GetVoiceHandler().Play(cScript_GetGlobalVarString(asTimer + "_Subject"), cScript_GetGlobalVarInt(asTimer + "_SpecificLineIdx"), cScript_GetGlobalVarString(asTimer + "_Callback"), cScript_GetGlobalVarInt(asTimer + "_Prio"), false);
}

//-------------------------------------------------

/**
 * Starts playing a voice, but if another one is already playing it queues it until no other sound is playing and some custom conditions are met.
 * 
 * @param asSubject The name of the subject to play.
 * @param asConditionCallback, if not "", this callback will be called to check if the subject can be played. Syntax bool f(const tString& in asSubject)
 * @param afMaxCheckTime, the max amount of time that it wil check if the conditions are met. If time runs out, the subject is never played. If below 0, then time never runs out.
 * @param afMinQuietTime, the minimum amount of time there should have been no other voices playing for it is possible to play the subject. If below 0, then voice playing check is skipped.
 * @param asVoiceCallback, called when subject is done playing. Syntax: void Func(const tString&in asScene, const tString&in asSubject)
 * @param alPrio, The priority of the voice, if higher than the currently playing, the current gets stopped and replaced, else this voice is not played.
 **/
void Voice_PlayWhenPossible(const tString&in asSubject, const tString&in asConditionCallback="", 
							float afMaxCheckTime=30.0f, float afMinQuietTime=5.0f, 
							const tString&in asVoiceCallback="", int alPrio=0)
{
	tString sName = "_VQEntry_"+asSubject;
	
	cScript_SetGlobalVarString(sName+"_Subject", asSubject);
	cScript_SetGlobalVarString(sName+"_CondCallback", asConditionCallback);
	cScript_SetGlobalVarString(sName+"_VoiceCallback", asVoiceCallback);
	cScript_SetGlobalVarInt(sName+"_Count", afMaxCheckTime>=0 ? int(afMaxCheckTime / 0.2f) : -1 );
	cScript_SetGlobalVarFloat(sName+"_MinQuietTime", afMinQuietTime );
	cScript_SetGlobalVarFloat(sName+"_QuietTimeCount", Voice_AnySceneIsActive() ? 0 : afMinQuietTime);
	cScript_SetGlobalVarInt(sName+"_Prio", alPrio );
	
	Map_AddTimer(sName, 0.0f, "$_Voice_PlayWhenPossible_CheckTimer");
}

void _Voice_PlayWhenPossible_CheckTimer(const tString&in asTimer)
{
	const float fTimeStep=0.2f;
	
	/////////////////////////////
	// Check if too long time has passed
	int lCount = cScript_GetGlobalVarInt(asTimer+"_Count");
	if(lCount>=0)
	{
		lCount--;
		if(lCount<=0) return;
		cScript_SetGlobalVarInt(asTimer+"_Count", lCount);	
	}
	
	/////////////////////////////
	// Check if voice is playing
	float fMinQuietTime = cScript_GetGlobalVarFloat(asTimer+"_MinQuietTime");
	if(fMinQuietTime>=0 && Voice_AnySceneIsActive())
	{
		cScript_SetGlobalVarFloat(asTimer+"_QuietTimeCount", 0);
		Map_AddTimer(asTimer, fTimeStep, "$_Voice_PlayWhenPossible_CheckTimer");
		return;
	}
	
	/////////////////////////////
	// Check custom callback
	tString sSubject = cScript_GetGlobalVarString(asTimer+"_Subject");
	tString sCondCallback =  cScript_GetGlobalVarString(asTimer+"_CondCallback");
	if(sCondCallback != "")
	{
		cLuxMap@ pMap = cLux_GetCurrentMap();
		
		bool bRet = true;
		if(pMap.ScriptPrepare("bool "+sCondCallback+"(const tString&in)"))
		{
			pMap.SetArgString(0, sSubject);
			
			if(pMap.ScriptExecute())
			{
				bRet = pMap.GetReturnBool();
			}
		}
		
		if(bRet==false)
		{
			cScript_SetGlobalVarFloat(asTimer+"_QuietTimeCount", 0);
			Map_AddTimer(asTimer, fTimeStep, "$_Voice_PlayWhenPossible_CheckTimer");
			return;
		}
	}
	
	/////////////////////////////
	// Check if it has been quiet long enough.
	float fQuietTimeCount = cScript_GetGlobalVarFloat(asTimer+"_QuietTimeCount");
	if(fQuietTimeCount<fMinQuietTime)
	{
		cScript_SetGlobalVarFloat(asTimer+"_QuietTimeCount", fQuietTimeCount+fTimeStep);
		Map_AddTimer(asTimer, fTimeStep, "$_Voice_PlayWhenPossible_CheckTimer");
		return;
	}
	
	/////////////////////////////
	// Play voice
	tString sVoiceCallback = cScript_GetGlobalVarString(asTimer+"_VoiceCallback");
	int lPrio = cScript_GetGlobalVarInt(asTimer+"_Prio");
		
	cLux_GetVoiceHandler().Play(sSubject, -1, sVoiceCallback, lPrio, false);
}

//-------------------------------------------------

/**
 * If Voice_PlayWhenPossible was called and set to run indefinitely, this function will stop the periodic check
 * 
 * @param asSubject The name of the subject.
 **/
void Voice_StopCheckTimer(const tString&in asSubject)
{
	tString sName = "_VQEntry_"+asSubject;
	Map_RemoveTimer(sName);
}

//-------------------------------------------------

/**
 * If a subject is queued (still not played) after started with Voice_PlayWhenPossible, use this to remove it and make sure it never plays
 * 
 * @param asSubject The name of the subject that is queued.
 **/
void Voice_AbortIfQueued(const tString&in asSubject)
{
	tString sName = "_VQEntry_"+asSubject;
	Map_RemoveTimer(sName);
}

//-------------------------------------------------

/**
 * Clears all queued subjects.
 **/
void Voice_ClearQueued()
{
	array<tString> vTimers;
	
	cLux_GetCurrentMap().GetTimersNamed("_VQEntry_*", vTimers);
	for(uint i=0;i<vTimers.length();++i)
	{
		cLux_AddDebugMessage("Removing queued:"+vTimers[i]);
		Map_RemoveTimer(vTimers[i]);
	}
}

//-------------------------------------------------

/**
 * If a subject is queued with Voice_PlayWhenPossible, return true
 * 
 * @param asSubject The name of the subject that is queued.
 **/
bool Voice_IsQueued(const tString&in asSubject)
{
	tString sName = "_VQEntry_"+asSubject;
	return Map_TimerExists(sName);
}

//-------------------------------------------------

/**
 * Checks if the specified subject exists.
 * 
 * @param asSubject The name of the subject
 **/
bool Voice_SubjectExists(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().SubjectExists(asSubject);
}

//-------------------------------------------------

/**
 * Checks if the subject has unplayed lines. Useful for testing if we've run out of barks.
 * 
 * @param asSubject The name of the subject
 **/
bool Voice_SubjectHasUnplayedLines(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().DoesSubjectHaveUnplayedLines(asSubject);
}


//-------------------------------------------------

/**
 * Gets the number of subject lines in a subject. Returns 0 if the subject does not exist.
 * 
 * @param asSubject The name of the subject
 **/
int Voice_GetSubjectLineNumber(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().GetSubjectLineNumber(asSubject);
}

//-------------------------------------------------

/**
 * Gets the name of the scene that the specified subject belongs to.
 * 
 * @param asSubject, The name of the subject
 * 
 * @return tString, The scene the subject belongs to.
 **/
tString Voice_GetSubjectSceneName(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().GetSubjectSceneName(asSubject);
}

//-------------------------------------------------

/**
 * Sets the source of voice. Note that this can be a moving entity.
 * 
 * @param asCharacter The name of the character (as defined in voice file)
 * @param asEntityName The entity the sound will be attached to
 * @param afMinDistance The distance when the volume of the voice start getting lower.
 * @param afMaxDistance Max distance the voice can be heard.
 * @param abUse3D If 3D effects (panning) are used for the voice.
 * @param afMaxPlayerListeningRange The maximum range that the player is considered listening.
 * @param afMinFreq The cutoff freqeuncy at min distance 0 - 22000 hz
 * @param afMaxFreq The cutoff freqeuncy at max distance 0 - 22000 hz
 * @param aFrequencyFlags Which pass the frequency should affect. eLuxVoiceSourceFreqencyFlag, 0 = none, 1 = low pass, 2 = high pass, 3 = both
 **/
 void Voice_SetSource(const tString &in asCharacter, const tString &in asEntityName, float afMinDistance, float afMaxDistance, bool abUse3D, float afMaxPlayerListeningRange=-1, float afMinFreq=22000, float afMaxFreq=22000, eLuxVoiceSourceFreqencyFlag aFrequencyFlags=eLuxVoiceSourceFreqencyFlag_None)
{
	cLux_GetCurrentMap().SetVoiceSource(asCharacter, asEntityName, afMinDistance, afMaxDistance, abUse3D, 
									    afMaxPlayerListeningRange >= 0 ? afMaxPlayerListeningRange : afMaxDistance, afMinFreq, afMaxFreq, aFrequencyFlags);	
}

//-------------------------------------------------
/**
 * Stops all voices playing
 * 
 **/
void Voice_StopAll()
{
	cLux_GetVoiceHandler().StopAll();
}

//-------------------------------------------------

/**
 * Stops all voices in a scene.
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 **/
void Voice_Stop(const tString& in asScene)
{
	cLux_GetVoiceHandler().Stop(asScene);
}

//-------------------------------------------------

/**
 * Stops all voices in a scene that contains character.
 * 
 * @param asCharacter Name of the character (as defined in the voice file)
 **/
void Voice_StopScenesWithCharacter(const tString& in asCharacter)
{
	cLux_GetVoiceHandler().StopScenesWithCharacter(asCharacter);
}

//-------------------------------------------------


/**
 * Skips the current line (same as stop but response triggers are used)
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 **/
void Voice_SkipCurrentLine(const tString& in asScene)
{
	cLux_GetVoiceHandler().SkipCurrentLine(asScene);
}

/**
 * Skips the current sound and jumps to next (if any)
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 **/
void Voice_SkipCurrentSound(const tString& in asScene)
{
	cLux_GetVoiceHandler().SkipCurrentSound(asScene);
}

/**
 * Like SkipCurrentSound, but if there is subtitle it makes sure it is displayed first. 
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 **/
void Voice_AdvanceFromCurrentSound(const tString& in asScene)
{
	cLux_GetVoiceHandler().AdvanceFromCurrentSound(asScene);
}

//-------------------------------------------------

/**
 * Stops all voices in a scene.
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 * @param abX If the scene is to be paused or resumed
 **/
void Voice_SetPaused(const tString& in asScene, bool abX)
{
	cLux_GetVoiceHandler().SetPaused(asScene, abX);
}

/**
 * Stops all active voice scenes
 * 
 * @param abX If all active scenes is to be paused or resumed
 **/
void Voice_SetPausedAll(bool abX)
{
	cLux_GetVoiceHandler().SetPausedAll(abX);
}
//-------------------------------------------------

/**
 * Sets the focus for a scene even if a scene with higher focusprio is playing. This makes the voices in the scene show subtitles and voices from other scenes lower.
 * This will stay in effect until another scene is set.
 * Note that a new subject in a scene with higher focus prio will override this.
 * 
 * @param asScene Name of the scene (as defined in the voice file). "" sets focus to no scene.
 **/
void Voice_SetFocusScene(const tString&in asScene)
{
	cLux_GetVoiceHandler().SetFocusScene(asScene);
}

//-------------------------------------------------

/**
 * Fades the volume of the voices from a specfic scene
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 * @param afVolume Volume to fade to,
 * @param afTime The amount of time the fade takes.
 **/
void Voice_FadeSceneVolumeTo(const tString&in asScene, float afVolume, float afTime)
{
	cLux_GetVoiceHandler().FadeSceneVolumeTo(asScene, afVolume, afTime);
}

//-------------------------------------------------

/**
 * If a character is currently speaking (i.e their voice is played).
 * 
 * @param asCharacter Name of the character (as defined in the voice file)
 **/
bool Voice_CharacterIsSpeaking(const tString&in asCharacter)
{
	return cLux_GetVoiceHandler().CharacterIsSpeaking(asCharacter);
}

//-------------------------------------------------

/**
 * If the specified scene is currently active.
 * 
 * @param asScene Name of the scene (as defined in the voice file)
 * 
 * @return bool, true if scene is currently active.
 **/
bool Voice_SceneIsActive(const tString&in asScene)
{
	return cLux_GetVoiceHandler().SceneIsActive(asScene);
}

//-------------------------------------------------

/**
 * If the specified subject is currently being played.
 * 
 * @param asSubject Name of the subject (as defined in the voice file)
 * 
 * @return bool, true if subject is currently active.
 **/
bool Voice_SubjectIsPlaying(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().SubjectIsPlaying(asSubject);
}

//-------------------------------------------------
/**
 * If the specified subject is currently being played 
 * and we're playing its last line, return how much time
 * is left on that line. Otherwise return -1.0f
 * 
 * @param asSubject Name of the subject (as defined in the voice file)
 * 
 * @return flat, -1.0f means we're not playing the last line of this subject,
 * otherwise returns the remaining time.
 **/
float Voice_GetTimeLeftOnLastLineOfPlayingSubject(const tString&in asSubject)
{
	return cLux_GetVoiceHandler().GetTimeLeftOnLastLineOfPlayingSubject(asSubject);
}

//-------------------------------------------------

/**
 * If any scene is currently active.
 * 
 * @return bool, true if any scene is currently active.
 **/
bool Voice_AnySceneIsActive()
{
	return cLux_GetVoiceHandler().AnySceneIsActive();
}

//-------------------------------------------------

/**
 * True if a scene involving this character is currently active.
 *  
 * @param asCharacter Name of the character (as defined in the voice file)
 * @return bool, true if any scene involving the character is currently active.
 **/
bool Voice_SceneInvolvingCharacterIsActive(const tString&in asCharacter)
{
	return cLux_GetVoiceHandler().SceneInvolvingCharacterIsActive(asCharacter);
}

//-------------------------------------------------

/**
 * Sets a callback that is called when a character starts and stops speaking. 
 * If character callback exists, the callback func is replaced with the latest one.
 * 
 * @param asCharacter, Name of the character
 * @param asCallback, Callbackfunction. Syntax: bool func(const tString &in asCharacter, bool abStartedTalking), if false is returned the callback is removed.
 **/
void Voice_SetCharacterSpeakingCallback(const tString&in asCharacter, const tString&in asCallback)
{
	cLux_GetVoiceHandler().AddCharacterSpeakingCallback(asCharacter, asCallback);
}

//-------------------------------------------------

/**
 * Removes a callback that is called when a character starts and stops speaking
 * 
 * @param asCharacter, Name of the character
 **/
void Voice_RemoveCharacterSpeakingCallback(const tString&in asCharacter)
{
	cLux_GetVoiceHandler().RemoveCharacterSpeakingCallback(asCharacter);
}

//-------------------------------------------------

/////////////////////////////////////////
// DIALOG
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Begins the declaration of a dialog. Must be called before any other dialog creation is done.
 * 
 * @param asName Name of the dialog
 **/
void Dialog_Begin(const tString &in asName="")
{
	cLux_GetDialogHandler().Begin(asName);
}

//-------------------------------------------------

/**
 * Ends the declaration of a dialog and starts the dialog. After this no more dialog creation funcs can be called without calling Dialog_Begin again.
 * 
 * @param asName Name of the branch to start playing. If empty first declared branch is started
 **/
void Dialog_End(const tString&in asStartBranch="")
{
	cLux_GetDialogHandler().End(asStartBranch);
}

//-------------------------------------------------

/**
 * Sets a callback function for the dialog. NOTE: Currently not used!
 **/
void Dialog_SetCallbackFunc(const tString&in asFunc)
{
	cLux_GetDialogHandler().SetCallbackFunc(asFunc);
}

//-------------------------------------------------

/**
 * Adds a branch (a list of subjects) to the dialog.
 * Dialog_Begin must be called before this is used!
 * 
 * @param asName Name of the branch.
 * @param asNextBranch The branch to start playing when this has ended. If empty, no new branch is played after this is over.
 **/
void Dialog_AddBranch(const tString&in asName, const tString&in asNextBranch="")
{
	cLux_GetDialogHandler().AddBranch(asName, asNextBranch);
}

//-------------------------------------------------

/**
 * Adds a branch with a single subject to the dialog. The branch gets the same name as the subject.
 * Dialog_Begin must be called before this is used!
 * 
 * @param asSubjectAndBranchName Shared name of both subject and branch.
 * @param asNextBranch The branch to start playing when this has ended. If empty, no new branch is played after this is over.
 * @param asCallback Callback function run at the start and end of subject. Syntax: "void asCallback(const tString&in asSubject, bool abStartOfSubject)
 **/
void Dialog_AddBranchAndSubject(const tString&in asSubjectAndBranchName, const tString&in asNextBranch="", const tString&in asCallback="")
{
	Dialog_AddBranch(asSubjectAndBranchName, asNextBranch);
		Dialog_AddSubject(asSubjectAndBranchName, asCallback);
}

//-------------------------------------------------

/**
 * Adds a subject to the latest added branch. The subjects will be played in order they are added.
 * Dialog_AddBranch must be called before this is used!
 * 
 * @param asSubject The name of the subject. This is [scene]_[subject], e.g. AdamAndEve_HowAboutEmApples
 * @param asCallback Callback function run at the start and end of subject. Syntax: "void asCallback(const tString&in asSubject, bool abStartOfSubject)
 **/
void Dialog_AddSubject(const tString&in asSubject, const tString&in asCallback="")
{
	cLux_GetDialogHandler().AddBranchSubject(asSubject, asCallback);
}

//-------------------------------------------------

/**
 * Adds a pause to the latest added branch. This pause will come after
 * Dialog_AddBranch must be called before this is used!
 * 
 * @param asSubject The length of the pause in seconds.
 * @param asCallback Callback function run at the start and end of pause. Syntax: "void asCallback(const tString&in asSubject, bool abStartOfSubject)
 **/
void Dialog_AddPause(float afTime, const tString&in asCallback="")
{
	cLux_GetDialogHandler().AddBranchPause(afTime, asCallback);
}


//-------------------------------------------------

/**
 * Set the response time for the response options. This is how long the player has to pick.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param afTime The time before the selection ends. 0=forever, this is default if not set.
 **/
void Dialog_SetResponseTimeLimit(float afTime)
{
	cLux_GetDialogHandler().SetResponseTimeLimit(afTime);
}

/**
 * Adds a response option that is shown after the subject is over. Max number is 4, +1 default (this actually depends on the game implementation, but this the default max).
 * Important: The defauly subject must be added last!
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asEntry This is the entry in the lang file, the category is the level name. If "" this option is used if time runs out. If needed, it must be added last!
 * @param asBranch Branch that will be switched to if chosen. If "", no new branch is played after this is over.
 * @param alOptionId Used in callback to see which option was picked (index is not good to use, becuase it is not always the same)
 * @param asCallback Called when the option has been chosen. Syntax: void asCallback(const tString&in asBranch, const tString&in asBranchSubject, int alOptionId)
 **/
void Dialog_AddResponseOption(const tString&in asEntry, const tString &in asBranch, int alOptionId=-1, const tString &in asCallback="")
{
	cLux_GetDialogHandler().AddResponseOption(asEntry, asBranch, alOptionId, asCallback);
}

//-------------------------------------------------

/**
 * Adds a condition that must be true for the option reponse option to be added. This checks if var is greater than 0.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 **/
void Dialog_AddResponseCondition_VarIsSet(const tString&in asVar)
{
	cLux_GetDialogHandler().AddResponseCondition(eLuxDialogOptionCondition_VarGreater, asVar, 0);
}

/**
 * Adds a condition that must be true for the option reponse option to be added. This checks if var is  less than 1
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 **/
void Dialog_AddResponseCondition_VarNotSet(const tString&in asVar)
{
	cLux_GetDialogHandler().AddResponseCondition(eLuxDialogOptionCondition_VarLesser, asVar, 1);
}

/**
 * Adds a condition that must be true for the option reponse option to be added. This checks if var is equal to a value.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 * @param alVal Value check is made against.
 **/
void Dialog_AddResponseCondition_VarEqual(const tString&in asVar, int alVal)
{
	cLux_GetDialogHandler().AddResponseCondition(eLuxDialogOptionCondition_VarEqual, asVar, alVal);
}

/**
 * Adds a condition that must be true for the option reponse option to be added. This checks if var is lesser than a value.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 * @param alVal Value check is made against.
 **/
void Dialog_AddResponseCondition_VarLesser(const tString&in asVar, int alVal)
{
	cLux_GetDialogHandler().AddResponseCondition(eLuxDialogOptionCondition_VarLesser, asVar, alVal);
}

/**
 * Adds a condition that must be true for the option reponse option to be added. This checks if var is greater than a value.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 * @param alVal Value check is made against.
 **/
void Dialog_AddResponseCondition_VarGreater(const tString&in asVar, int alVal)
{
	cLux_GetDialogHandler().AddResponseCondition(eLuxDialogOptionCondition_VarGreater, asVar, alVal);
}

//-------------------------------------------------

/**
 * Event that happens after option is picked. This sets the value of a variable.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 * @param alVal Value that is set
 **/
void Dialog_AddResponseEvent_SetVar(const tString&in asVar, int alVal=1)
{
	cLux_GetDialogHandler().AddResponseEvent(eLuxDialogOptionEvent_SetVar, asVar, alVal);
}

/**
 * Event that happens after option is picked. This increments the value of a variable.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable.
 * @param alVal Value that is added to the variabel.
 **/
void Dialog_AddResponseEvent_IncVar(const tString&in asVar, int alVal=1)
{
	cLux_GetDialogHandler().AddResponseEvent(eLuxDialogOptionEvent_IncVar, asVar, alVal);
}


//-------------------------------------------------

/**
 * This makes sure that the option is only shown once.
 * Dialog_AddResponseOption must be called before this is used!
 * 
 * @param asVar Name of the variable to keep track of this.
 **/
void Dialog_AddResponse_OneTimeCheck(const tString&in asVar)
{
	Dialog_AddResponseCondition_VarNotSet(asVar);
	Dialog_AddResponseEvent_SetVar(asVar);
}
//-------------------------------------------------

/**
 * Sets the value of an internal Dialog variableafter a subject is over.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param alValue The value to set the var.
 **/
void Dialog_AddEndEvent_SetVar(const tString&in asVar, int alValue=1)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_SetVar, alValue, asVar, "", true);
}

/**
 * Increments the value of an internal Dialog variable after a subject is over. If var was not set priorly, it will start with 0.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param alValue The value to set the var.
 **/
void Dialog_AddEndEvent_IncVar(const tString&in asVar, int alValue=1)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_IncVar, alValue, asVar, "", true);
}

/**
 * Checks if a variable as a value greater than 0 and exists.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_VarIsSet(const tString&in asVar, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_VarGreater, 0, asVar, "", true);
}

/**
 * Checks if a variable is equal to a value. If a variable does not exist it will assume to have value 0.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param alValue value the variable is checked against
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_VarEquals(const tString&in asVar, int alValue, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_VarEquals, alValue, asVar, asNewBranch, true);
}

/**
 * Checks if a variable is greater than a value. If a variable does not exist it will assume to have value 0.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param alValue value the variable is checked against
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_VarGreater(const tString&in asVar, int alValue, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_VarGreater, alValue, asVar, asNewBranch, true);
}

/**
 * Checks if a variable is lesser than a value. If a variable does not exist it will assume to have value 0.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asSubject Set name of the var
 * @param alValue value the variable is checked against
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_VarLesser(const tString&in asVar, int alValue, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_VarLesser, alValue, asVar, asNewBranch, true);
}

//-------------------------------------------------

/**
 * Adds a branching event to the latest added subject. Checked at end of every line. This event checks if player is out of range from all characters in the dialog, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddLineEvent_OutOfRange(const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_OutOfRange,0, "", asNewBranch, false);
}

/**
 * Adds a branching event to the latest added subject. Checked at end of the subject. This event checks if player is out of range from all characters in the dialog, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_OutOfRange(const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_OutOfRange,0, "", asNewBranch, true);
}

//-------------------------------------------------

/**
 * Adds a branching event to the latest added subject. Checked at end of every line. This event checks if is not looking at any character in the dialog, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddLineEvent_PlayerNotLooking(const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_PlayerNotLooking,0, "", asNewBranch, false);
}

/**
 * Adds a branching event to the latest added subject. Checked at end of the subject. This event checks if is not looking at any character in the dialog, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_PlayerNotLooking(const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_PlayerNotLooking,0, "", asNewBranch, true);
}

//-------------------------------------------------

/**
 * Adds a branching event to the latest added subject. Checked at end of every line. This event checks if is not looking at any character any character or is out of range, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddLineEvent_PlayerNotLookingOrOutOfRange(const tString&in asNewBranch)
{
	Dialog_AddLineEvent_OutOfRange(asNewBranch);
	Dialog_AddLineEvent_PlayerNotLooking(asNewBranch);
}

/**
 * Adds a branching event to the latest added subject. Checked at end of subject. This event checks if is not looking at any character any character or is out of range, and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_PlayerNotLookingOrOutOfRange(const tString&in asNewBranch)
{
	Dialog_AddEndEvent_OutOfRange(asNewBranch);
	Dialog_AddEndEvent_PlayerNotLooking(asNewBranch);
}

//-------------------------------------------------

/**
 * Adds a branching event to the latest added subject. Checked at end of every line. This event checks if a custom callback returns true and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asCallbackFunc The callback function name. Syntax: bool asCallbackFunc(const tString&in asBranch, const tString&in asBranchSubject, int alLineIndex, const tString&in asNewBranch)"
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddLineEvent_Callback(const tString&in asCallbackFunc, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_Callback,0, asCallbackFunc, asNewBranch, false);
}

/**
 * Adds a branching event to the latest added subject. Checked at end of the subject. This event checks if a custom callback returns true and if so branches.
 * Dialog_AddSubject must be called before this is used!
 * 
 * @param asCallbackFunc The callback function name. Syntax: "bool asCallbackFunc(const tString&in asBranch, const tString&in asBranchSubject, int alLineIndex, const tString&in asNewBranch)"
 * @param asNewBranch The name of the dialog to branch to. If empty, the dialog just ends.
 **/
void Dialog_AddEndEvent_Callback(const tString&in asCallbackFunc, const tString&in asNewBranch)
{
	cLux_GetDialogHandler().AddBranchEvent(eLuxDialogBranchEvent_Callback,0, asCallbackFunc, asNewBranch, true);
}

//-------------------------------------------------

/**
 * Checks if a character is currently taking part in a dialog.
 * 
 * @param asName Name of the character.
 **/
bool Dialog_CharacterIsActive(const tString&in asName)
{
	return cLux_GetDialogHandler().CharacterIsActive(asName);
}

//-------------------------------------------------

/**
 * Stops a dialog
 * 
 * @param asName Name of the dialog
 **/
void Dialog_Stop(const tString&in asName)
{
	cLux_GetDialogHandler().Stop(asName);
}

//-------------------------------------------------

/**
 * Stops all dialog
 * 
 **/
void Dialog_StopAll()
{
	cLux_GetDialogHandler().StopAll();
}

//-------------------------------------------------

/**
 * Starts a dialog with an entity that has a CharMover. Should only be used internally by entities.
 * 
 **/
void Dialog_StartConversation_CharMover(const tString&in asVoiceCharacter, 
										const tString&in asFocusEntityName, int alHeadBoneIndex, cLuxCharMover@ apCharMover,
										float afMinTurnAngle, float afMaxMoveDist = 0.5f)
{
	/////////////////////////////////////
	// Set up the player state
	cScript_SetGlobalArgString(0, asVoiceCharacter); 
	cScript_SetGlobalArgString(1, asFocusEntityName); 
	cScript_SetGlobalArgFloat(2, afMaxMoveDist); 
	cScript_SetGlobalArgInt(3, alHeadBoneIndex);
	cScript_SetGlobalArgVector3f(4, cVector3f_Zero);
	
	cScript_RunGlobalFunc("State_Conversation", "", "SetupConversation");
	
	cLux_GetPlayer().ChangeState(ePlayerState_Conversation);	
	
	/////////////////////////////////////
	// Turn the character if needed
	if(apCharMover !is null)
	{
		cVector3f vFeetPos = cLux_GetPlayer().GetCharacterBody().GetFeetPosition();
		
		cVector3f vToPlayer = vFeetPos - apCharMover.GetCharBody().GetPosition();
		vToPlayer.y=0; vToPlayer.Normalize();
		
		cVector3f vFwd = apCharMover.GetCharBody().GetForward();
		vFwd.y=0; vFwd.Normalize();
		
		float fAngle = cMath_Vector3Angle(vFwd, vToPlayer);
		
		if(fAngle>=afMinTurnAngle)
		{
			apCharMover.TurnToPos(vFeetPos);
		}
	}
}

//-------------------------------------------------

/**
 * Starts a dialog with an entity, moving the player to a position to have the conversation.
 * 
 * @param asVoiceCharacter, the character with wich the player will have the dialog.
 * @param asFocusEntity, the entity the player will look at during the dialog.
 * @param asPositionArea, the area the player will be moved to at the start of the conversation (centre base of area = foot position)
 * @param asHeadBone, if non-"", the bone of asFocusEntity that should be focused on during the conversation (e.g. "head")
 * @param afMaxMoveDist, the max distance that can be moved from where the player is standing when the dialog starts.
 * @param avFocusOffset, any offset that should be added to the focus position (origin of focusEntity, or head bone position if specified)
 * 
 **/
void Dialog_StartConversation_PosBased(const tString& in asVoiceCharacter, const tString& in asFocusEntity, const tString& in asPositionArea, const tString& in asHeadBone="", float afMaxMoveDist = 0.5f, cVector3f avFocusOffset = cVector3f_Zero)
{
	if ((asPositionArea=="")||(asFocusEntity=="")||(asVoiceCharacter==""))
	{
		Error("Empty argument for Dialog_StartConversation_PosBased - can't start conversation.");
		return;
	}

	//////////////////////////
	// Get entity
	iLuxEntity@ pEntity = cLux_GetCurrentMap().GetEntityByName(asFocusEntity);
	if(pEntity is null)
	{
		Error("Could not find entity with name '"+asFocusEntity+"' for Dialog_StartConversation_PosBased");
		return;
	}
	
	/////////////////////////////////////
	// Set up the player state
	cScript_SetGlobalArgString(0, asVoiceCharacter); 
	cScript_SetGlobalArgString(1, asFocusEntity); 
	cScript_SetGlobalArgString(2, asPositionArea); 
	cScript_SetGlobalArgFloat(3, afMaxMoveDist); 
	cScript_SetGlobalArgVector3f(4, avFocusOffset); 
	
	int lBoneIndex = -1;
	if ((asHeadBone!="")&&(pEntity.GetMeshEntity() !is null))
	{
		lBoneIndex = pEntity.GetMeshEntity().GetBoneStateIndex(asHeadBone);
		if (lBoneIndex==-1)
			Error("Couldn't find head bone '"+asHeadBone+"' for entity'"+asFocusEntity+"' for Dialog_StartConversation_PosBased");
	}
	
	cScript_SetGlobalArgInt(5, lBoneIndex);
	
	cScript_RunGlobalFunc("State_Conversation", "", "SetupPosBasedConversation");
	
	cLux_GetPlayer().ChangeState(ePlayerState_Conversation);
}

//-------------------------------------------------

/**
 * Starts a dialog with an entity.
 * 
 * @param asVoiceCharacter, the character with wich the player will have the dialog.
 * @param asFocusEntityName, the entity the player will look at during the dialog.
 * @param afMaxMoveDist, the max distance that can be moved from where the player is standing when the dialog starts.
 * @param abManualStateTransition, if the state can only be exited by changing state manually
 * @param afZoomMul, multiplier for the FOV zoom effect when entering the conversation
 * 
 **/
void Dialog_StartConversation(const tString&in asVoiceCharacter, const tString&in asFocusEntityName, float afMaxMoveDist = 0.5f, 
							  cVector3f avFocusOffset = cVector3f_Zero, bool abManualStateTransition = false, float afZoomMul = 1.f)
{
	//////////////////////////
	// Get entity
	iLuxEntity@ pEntity = cLux_GetCurrentMap().GetEntityByName(asFocusEntityName);
	if(pEntity is null)
	{
		Error("Could not find entity with name '"+asFocusEntityName+"' for Dialog_StartConversation");
		return;
	}
	
	/////////////////////////////////////
	// Set up the player state
	cScript_SetGlobalArgString(0, asVoiceCharacter); 
	cScript_SetGlobalArgString(1, asFocusEntityName); 
	cScript_SetGlobalArgFloat(2, afMaxMoveDist); 
	cScript_SetGlobalArgInt(3,-1);	// Head bone index
	cScript_SetGlobalArgVector3f(4,avFocusOffset);
	cScript_SetGlobalArgBool(5, abManualStateTransition);
	cScript_SetGlobalArgFloat(6, afZoomMul);
	
	cScript_RunGlobalFunc("State_Conversation", "", "SetupConversation");
	
	cLux_GetPlayer().ChangeState(ePlayerState_Conversation);
}

//-------------------------------------------------

void Dialog_StopConversation()
{
	cLux_GetPlayer().ChangeState(ePlayerState_Normal);
}

//-------------------------------------------------

/**
 * Gets the scene the character is currently in.
 * 
 * @param asScene Name of the character (as defined in the voice file)
 **/
 
tString Dialog_GetCharacterScene(const tString&in asCharacter)
{
	return cLux_GetDialogHandler().GetCharacterScene(asCharacter);
}
//-------------------------------------------------

/**
 * Sets the value of an internal Dialog variable 
 * 
 * @param asSubject Set name of the var
 * @param alValue The value to set the var.
 **/
void Dialog_SetVar(const tString&in asVar, int alValue=1)
{
	cLux_GetDialogHandler().SetVar(asVar, alValue);
}

/**
 * Incremements the value of an internal Dialog variable. If var was not set priorly, it will start with 0.
 * 
 * @param asSubject Set name of the var
 * @param alValue The value to set the var.
 **/
void Dialog_IncVar(const tString&in asVar, int alValue=1)
{
	cLux_GetDialogHandler().IncVar(asVar, alValue);
}

/**
 * Gets the value of an internal Dialog variable. If it does not exist, 0 is returned.
 * 
 * @param asSubject Set name of the var
 * @param alValue The value to set the var.
 **/
int Dialog_GetVar(const tString&in asVar)
{
	return cLux_GetDialogHandler().GetVar(asVar);
}

//-------------------------------------------------

/**
 * Returns a list of the characters who speak in a particular dialog subject.
 * 
 * @param, asSubject, name of subject
 * @param, avOutCharacters, array<tString> to hold the resulting list
 */
void Dialog_GetCharactersInSubject(const tString&in asSubject, array<tString>&out avOutCharacters)
{
	cLux_GetDialogHandler().GetCharactersInSubject(asSubject,avOutCharacters);
}

//-------------------------------------------------

