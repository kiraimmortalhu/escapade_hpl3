//----------------------------------------------------------------------
//----------------------------------------------------------------------

////////////////////////////////
// RAT KING (by ValG and DoctorD
////////////////////////////////

//----------------------------------------------------------------------

#include "base/Base_Types.hps"
#include "interfaces/Agent_Interface.hps"
#include "custom/agents/agent_types_custom.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_player.hps"
#include "custom/helpers/helper_modules_custom.hps"
#include "custom/helpers/helper_areas_custom.hps"
#include "custom/components/ComponentInterfaces_Custom.hps"

//----------------------------------------------------------------------

/////////////////////////////////////////
// SOUND
//{//////////////////////////////////////

//----------------------------------------------------------------------

const tString gsRatSound_Eat = "";
const tString gsRatSound_Walk = "update/big_rat/walk";
const tString gsRatSound_Attack = "update/big_rat/attack";
const tString gsRatSound_BloodReact = "update/big_rat/blood_react";
const tString gsRatSound_Sniff = "update/big_rat/sniff";
const tString gsRatSound_Death = "update/big_rat/death";
const tString gsRatSound_Alert = "update/big_rat/warning";
const tString gsRatSound_Fear = "update/big_rat/fear";
const tString gsRatSound_FearFlame = "update/big_rat/flame_react";
const tString gsRatSound_FearRun = "update/big_rat/fear_run";
const tString gsRatSound_AttackWarning = "update/big_rat/attack_warn";

//----------------------------------------------------------------------

//} END SOUND

//----------------------------------------------------------------------

/////////////////////////////////////////
// ANIMATION
//{//////////////////////////////////////

//----------------------------------------------------------------------


const tString gsRatAnim_Normal_Walk = "walk";
const tString[] gvRatAnim_Normal_Idle = { "idle_stand_01", "idle_stand_02", "idle_stand_03" };

const tString gsRatAnim_Walk_TurnLeft = "walk_turn_left";
const tString gsRatAnim_Walk_TurnRight = "walk_turn_right";
const tString gsRatAnim_Run_TurnLeft = "walk_turn_left";
const tString gsRatAnim_Run_TurnRight = "walk_turn_right";

const tString[] gvRatAnim_Sniff = { "sniff_stand_01", "sniff_stand_02" };
const tString gsRatAnim_Sniff_Walk = "walk_sniff";
const tString gsRatAnim_Sniff_Idle = "idle_sniff";
const tString gsRatAnim_Sniff_Walk_TurnLeft = "walk_turn_left_sniff";
const tString gsRatAnim_Sniff_Walk_TurnRight = "walk_turn_right_sniff";

const tString gsRatAnim_Alert = "idle_aggro";
const tString gsRatAnim_Eat = "eating";
const tString[] gvRatAnim_EatVariation = { "eating_extra_1", "eating_extra_2", "eating_extra_3" }; 
const tString[] gvRatAnim_Attack = { "attack_left", "attack_right" }; 
const tString[] gvRatAnim_AttackFast = { "attack_left_fast", "attack_right_fast" }; 
const tString[] gvRatAnim_Death = { "death_01", "death_02", "death_03", "death_04", "death_05" }; 

const tString gsRatAnim_Shot_Front = "death_shot_front";
const tString gsRatAnim_Shot_Back = "death_shot_back";
const tString gsRatAnim_Shot_Left = "death_shot_left";
const tString gsRatAnim_Shot_Right = "death_shot_right";

const tString gsRatAnim_Attack_Idle = "idle_aggro";

const tString gsRatAnim_Warning = "idle_attack";

const tString gsRatAnim_TurnAround = "turn_180";

//----------------------------------------------------------------------

//} END ANIMATION

//----------------------------------------------------------------------

/////////////////////////////////////////
// SETTINGS
//{//////////////////////////////////////

//----------------------------------------------------------------------

const float gfRat_EatTimeMin = 60.0f;
const float gfRat_EatTimeMax = 120.0f;
const float gfRat_EatBodyActivationDist = 12.0f;
const float gfRat_AlertDistMinSqr = 10.0f*10.0f;
const float gfRat_ForceAttackDistSqr = 6.5f * 6.5f;
const float gfRat_AlertTimeMin = 0.0f;
const float gfRat_AlertTimeMax = 0.7f;
const float gfRat_UnalertTimeMin = 4.0f;
const float gfRat_UnalertTimeMax = 7.0f;
const float gfRat_AttackMinDistUntilRetreat = 20.f;
const float gfRat_AttackMaxDistUntilRetreat = 30.f;
const float gfRat_AttackMinDistUntilRetreat_NoDamage = 20.f;
const float gfRat_AttackMaxDistUntilRetreat_NoDamage = 30.f;
const float gfRat_AttackMinDistUntilRetreat_FromEating = 20.f;
const float gfRat_AttackMaxDistUntilRetreat_FromEating = 30.f;
const float gfRat_AttackMinTimeUntilRetreat = 20.f;
const float gfRat_AttackMaxTimeUntilRetreat = 25.f;
const float gfRat_AttackDistanceSqr = 3.0f;
const float gfRat_AttackMinPlayerRetreatTime = 20.f;
const float gfRat_AttackMaxPlayerRetreatTime = 21.f;
const float gfRat_BiteMinDistanceSqr = 0.6f*0.6f;
const float gfRat_BiteDamage = 0.1f;
const float gfRat_BiteDamage_FullHealth = 0.2f;
const float gfRat_GrenadeRetreatMinDistSqr = 6.f * 6.f;
const float gfRat_MolotovRetreatMinDistSqr = 4.f * 4.f;
const float gfRat_FlareRetreatMinDistSqr = 6.f * 6.f;
const float gfRat_BulletImpactAttackMinDistSqr = 2.f * 2.f;
const float gfRat_GunShotPlayerAttackMinDistSqr = 5.f * 5.f;
const float gfRat_PostAttackMaxDistToPlayerSqr = 2.f * 2.f;
const float gfRat_ReachedBloodTrailDistSqr = 1.5f * 1.5f;
const float gfRat_BloodTrailConnectionMaxDist = 15.f;
const float gfRat_BloodTrailMaxFollowTime = 45;
const float gfRat_SmellPlayerRadius = 6.f;
const float gfRat_SmellPlayerTimeMin = 1.5f;
const float gfRat_SmellPlayerTimeMax = 3.f;
const float gfRat_SmellFoodTimeMin = 1.5f;
const float gfRat_SmellFoodTimeMax = 3.f;
const float gfRat_SmellForceAttackPlayerMinDistSqr = 1.5f;
const int glRat_SkipRetreatMinAttackingRatNum = 0;
const float gfRat_ThreatenedDistMax = 6.f; 
const float gfRat_ThreatenedDistMin = 1.f;
const float gfRat_ThreatenedDistMaxSqr = gfRat_ThreatenedDistMax * gfRat_ThreatenedDistMax; 
const float gfRat_ThreatenedDistMinSqr = gfRat_ThreatenedDistMin * gfRat_ThreatenedDistMin;
const float gfRat_ThreatenedBackstepDistMaxSqr = 2.f * 2.f;
const float gfRat_HungerTimeMin = 60.0f;
const float gfRat_HungerTimeMax = 120.f;

const float gfRat_FreeSlotDelay_Default = 25.0f;
const float gfRat_FreeSlotDelay_Brief = 10.0f;
const float gfRat_FreeSlotDelay_Death = 60.0f * 5.0f;

const float gfRat_StalkPlayerMinDistSqr = 3.0f*3.0f;
const float gfRat_StalkPlayerMaxDistSqr = 7.0f*7.0f;
const float gfRat_StalkPlayerFleeDistSqr = 1.75f*1.75f;
const float gfRat_StalkPlayerFollowTime = 7.5f;
const float gfRat_StalkPlayerAttackTime = 10.0f;
const int glRat_StalkPlayerMinRatsBeforeAttack = 0;
	
const float gfRat_PlayTurnAroundAnimMinAngle = cMath_ToRad(140.f);
const float gfRat_MinTimeBetweenQuickTurns = 2.0f;

const int glRat_ExtremeRatterGoal = 5;

const cVector3f gvRat_EatingBodySize = cVector3f(0.5, 0.3, 0.5);

// ValG edit, item drop
const tString glRat_KeyPickupEntity = "church_key.ent";

//----------------------------------------------------------------------

//} END SETTINGS

//----------------------------------------------------------------------

/////////////////////////////////////////
// TYPES
//{//////////////////////////////////////

//----------------------------------------------------------------------


enum eRatState
{
	eRatState_Eat,
	eRatState_FindFood,
	eRatState_Retreat,
	eRatState_GoToHole,
	eRatState_Emerge,
	eRatState_Hunt,
	eRatState_Attack,
	eRatState_PostAttack,
	eRatState_TrackBloodTrail,
	eRatState_Smell,
	eRatState_Dead,
	eRatState_Threatened,
	eRatState_WanderThenHide,
	eRatState_StalkPlayer
}

//----------------------------------------------------------------------

enum eRatEmergeType
{
	eRatEmergeType_Food,
	eRatEmergeType_Wander,
	eRatEmergeType_BloodTrail,
	
	eRatEmergeType_LastEnum
}

//----------------------------------------------------------------------

enum eRatRetreatReason
{
	eRatRetreatReason_Default,
	eRatRetreatReason_Flame
}

//----------------------------------------------------------------------

//} END TYPES

//----------------------------------------------------------------------

/////////////////////////////////////////
// CLASSES
//{//////////////////////////////////////

//----------------------------------------------------------------------

//class cRat_XXX
//{
//}

//----------------------------------------------------------------------

//} END CLASSES

//----------------------------------------------------------------------

class cScrAgentRat : iScrAgent, iScrAgent_Interface
{
	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// MAIN FUNCTIONS
	//=======================================
	//{//////////////////////////////////////
	
	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// INIT
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void Init()
	{
		mBaseObj.SetUpdatePlayerDetection(false);
		mBaseObj.SetCheckForDoors(false);
	}
	
	//------------------------------------------------------------

	//} END INIT

	//------------------------------------------------------------

	/////////////////////////////////////////
	// LOADING
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void SetupCharBody()
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		pCharBody.SetMass(5.f);	
		pCharBody.SetCustomGravityActive(false);
		pCharBody.SetAccurateClimbing(false);
		pCharBody.SetMaxNoSlideSlopeAngle(cMath_ToRad(50.f));
		pCharBody.SetMaxPushMass(10.f);
		pCharBody.SetMaxPushForce(90.f);
		pCharBody.SetPushImpulse(5.f);
		pCharBody.SetCharacterMaxPushMass(6.f);
		pCharBody.SetCharacterPushForce(36.f);
		pCharBody.SetMaxStepSize(0.4f);
		pCharBody.SetMaxStepSizeInAir(0.2f);
		pCharBody.SetStepClimbSpeed(1.f);
		pCharBody.SetCollideCharacter(false);
		pCharBody.SetMaxCollisionPoints(4);
		pCharBody.SetSeparateMoveAndForceCollision(false);
		
		pCharBody.SetMaxPositiveMoveSpeed(eCharDir_Forward, 1.f);
		pCharBody.SetMaxNegativeMoveSpeed(eCharDir_Forward, -1.f);
		pCharBody.SetMaxPositiveMoveSpeed(eCharDir_Right, 1.f);
		pCharBody.SetMaxNegativeMoveSpeed(eCharDir_Right, -1.f);
		pCharBody.SetMoveSpeedMul(eCharDir_Forward, 1.f);
		pCharBody.SetMoveAcc(eCharDir_Forward, 1.f);
		pCharBody.SetMoveDeacc(eCharDir_Forward, 1.f);
		pCharBody.SetMoveAcc(eCharDir_Right, 1.f);
		pCharBody.SetMoveDeacc(eCharDir_Right, 1.f);
		pCharBody.SetMoveOppositeDirAccMul(eCharDir_Forward, 1.f);
		pCharBody.SetMoveOppositeDirAccMul(eCharDir_Right, 1.f);
		
		pCharBody.SetCollideFlags(mBaseObj.GetMap().GetCollideFlag("-player"));
		
		pCharBody.AddExtraSize(gvRat_EatingBodySize);
	}

	//------------------------------------------------------------

	void SetupAfterLoad(cWorld@ apWorld, cResourceVarsObject@ apVars, cResourceVarsObject@ apInstanceVars)
	{
		/////////////
		// General		
		mBaseObj.SetAlignEntityWithGroundRay(true);
		mBaseObj.SetFOV(cMath_ToRad(130.f));
		mBaseObj.SetSightRange(20.f);
		mBaseObj.SetSightRangeMul(1.f);
		mBaseObj.SetRelativeEyeHeight(0.1f);		
		
		mBaseObj.GetMeshEntity().SetVariableAnimationUpdate(true);
		
		mbSpawnAtPos = apInstanceVars.GetVarBool("Rat_SpawnAtPos", false);
		
		/////////////
		// State machine
		@mpStateMachine = cLux_CreateEntityComponent_StateMachine(mBaseObj);
		
		mpStateMachine.AddState("Eat", eRatState_Eat);
		mpStateMachine.AddState("FindFood", eRatState_FindFood);
		mpStateMachine.AddState("Retreat", eRatState_Retreat);
		mpStateMachine.AddState("GoToHole", eRatState_GoToHole);
		mpStateMachine.AddState("Emerge", eRatState_Emerge);
		mpStateMachine.AddState("Hunt", eRatState_Hunt);
		mpStateMachine.AddState("Attack", eRatState_Attack);
		mpStateMachine.AddState("PostAttack", eRatState_PostAttack);
		mpStateMachine.AddState("TrackBloodTrail", eRatState_TrackBloodTrail);
		mpStateMachine.AddState("Smell", eRatState_Smell);
		mpStateMachine.AddState("Dead", eRatState_Dead);
		mpStateMachine.AddState("Threatened", eRatState_Threatened);
		mpStateMachine.AddState("WanderThenHide", eRatState_WanderThenHide);
		mpStateMachine.AddState("StalkPlayer", eRatState_StalkPlayer);

		/////////////
		// Mover
		@mpMover = cLux_CreateEntityComponent_CharMover(mBaseObj, mBaseObj.GetCharBody());
		mpMover.LoadFromVariables(apVars);
		
		//////////////////////
		// Head Tracker
		@mpHeadTracker = cLux_CreateEntityComponent_HeadTracker(mBaseObj);
		mpHeadTracker.LoadFromVariables(apVars);
		mpHeadTracker.SetActive(false);
		msHeadTracker_TargetEntity = "Player";
		
		mpMover.SetupWallAvoidance(0.9f, 5.f, 4);
		mpMover.SetWallAvoidanceActive(false);
		mpMover.SetupDynamicObjectAvoidance(2.5f, 20.f, 1.f);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		mpMover.SetupDynamicObjectPlayerAvoidance(2.5f, 1.f);
		mpMover.SetDynamicObjectPlayerAvoidanceActive(false);
		mpMover.SetMaxForwardSpeed(1.f);
		mpMover.SetMaxBackwardSpeed(1.f);
		mpMover.SetRunToWalkSpeed(2.4f);
		mpMover.SetWalkToRunSpeed(2.6f);
		mpMover.SetTurnMinBreakAngle(cMath_ToRad(40.f));
		mpMover.SetTurnMinPlayAnimAngle(cMath_ToRad(40.f));
		mpMover.SetWalkTurnAnimNames(gsRatAnim_Walk_TurnLeft, gsRatAnim_Walk_TurnRight);
		mpMover.SetRunTurnAnimNames(gsRatAnim_Run_TurnLeft, gsRatAnim_Run_TurnRight);
		mpMover.SetTurnBreakMul(1.f);
		mpMover.SetTurnSpeedMul(6.f);
		mpMover.SetTurnMaxSpeed(12.f);
		mpMover.SetStoppedToWalkSpeed(0.05f);
		mpMover.SetWalkToStoppedSpeed(0.025f);
		mpMover.SetMoveSpeedAnimMul(0.5f);		
		mpMover.SetTurnSpeedAcc(30.0f);
		
		mpMover.AddSpeedState(eRatSpeed_SlowWalk);
			mpMover.SetSpeedState_Forward(1.f);
			mpMover.SetSpeedState_ForwardAcc(5.f);
			mpMover.SetSpeedState_ForwardDeacc(5.f);
			mpMover.SetSpeedState_TurnBreakMul(0.5f);
		
		mpMover.AddSpeedState(eRatSpeed_Walk);
			mpMover.SetSpeedState_Forward(2.f);
			mpMover.SetSpeedState_Backward(1.f);
			mpMover.SetSpeedState_ForwardAcc(5.f);
			mpMover.SetSpeedState_ForwardDeacc(10.f);
			mpMover.SetSpeedState_TurnBreakMul(0.75f);
			mpMover.SetSpeedState_TurnSpeedMul(2.0f);
		
		mpMover.AddSpeedState(eRatSpeed_Run);
			mpMover.SetSpeedState_Forward(5.f);
			mpMover.SetSpeedState_ForwardAcc(5.f);
			mpMover.SetSpeedState_ForwardDeacc(20.f);
			mpMover.SetSpeedState_TurnBreakMul(1.f);
		
		mpMover.AddSpeedState(eRatSpeed_Attack);
			mpMover.SetSpeedState_Forward(9.f);
			mpMover.SetSpeedState_ForwardAcc(9.f);
			mpMover.SetSpeedState_ForwardDeacc(60.f);
			mpMover.SetSpeedState_TurnBreakMul(0.25f);
			mpMover.SetSpeedState_TurnSpeedAcc(50.0f);
			mpMover.SetSpeedState_TurnSpeedMul(20.0f);
			
		mpMover.SetIdleAnimName(GetRandomAnim(gvRatAnim_Normal_Idle));
		 
		/////////////
		// Pathfinder
		@mpPathfinder = cLux_CreateEntityComponent_Pathfinder(mBaseObj);
		
		mpPathfinder.SetNodeContainerName("Rat");
		mpPathfinder.SetMaxHeight(0.8f);
		mpPathfinder.SetDirectPathMaxDistanceMul(1.0f);
		mpPathfinder.SetMaxEdgeDistance(3.f);
		mpPathfinder.SetFreePathRayNum(1);
		mpPathfinder.SetMaxGoalsPerIsland(4);

		EnvironmentalDamage_AddEntityToCheck(mBaseObj.GetID());
		
		//// ValG edit
		//// Preload
		
		cLux_PreloadEntity(glRat_KeyPickupEntity);
	}

	//------------------------------------------------------------

	void OnAfterWorldLoad()
	{
		/////////////////////
		// Head tracker
		if (msHeadTracker_TargetEntity != "")
		{
			iLuxEntity@ pEnt = mBaseObj.GetMap().GetEntityByName(msHeadTracker_TargetEntity);
			if (pEnt !is null)
			{
				m_idHeadTracker_TargetEntity = pEnt.GetID();
				mpHeadTracker.SetTrackEntity(pEnt);
			}
		}
	}
	
	//------------------------------------------------------------

	void OnMapEnter()
	{
		EnvironmentalDamage_AddEntityToCheck(mBaseObj.GetID());
		SetCollide(true);
	}

	void OnMapLeave()
	{
		EnvironmentalDamage_RemoveEntityToCheck(mBaseObj.GetID());
	}

	//------------------------------------------------------------
	
	void BeforeEntityDestruction()
	{
		EnvironmentalDamage_RemoveEntityToCheck(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------

	//} END LOADING

	//------------------------------------------------------------

	/////////////////////////////////////////
	// GENERAL
	//{///////////////////////////////////////

	//------------------------------------------------------------
	
	void OnUpdate(float afTimeStep)
	{
		cSystem_ProfileStart("Rat Update");
		
		////////////////////////////
		// Extra check to ensure dead rats don't return to life
		if ((mBaseObj.GetHealth() <= 0 || mBaseObj.GetRagdollActive()) && mpStateMachine.GetCurrentState() != eRatState_Dead)
		{
			if (mBaseObj.GetHealth() > 0)
				mBaseObj.GiveDamage(null, 0, 0, eDamageType_Default, mBaseObj.GetHealth(), 0, 0, 0, tID_Invalid, mBaseObj.GetMap().GetNewAttackInstanceID());
			mpStateMachine.ChangeState(eRatState_Dead);
			return;
		}
			

		UpdateQuickTurn(afTimeStep);

		bool bAllowPush = mpStateMachine.GetCurrentState() != eRatState_Eat;
		if (bAllowPush)
		{
			cVector3f vForce = mBaseObj.GetVarVector3f("CollisionPushForce");
			mBaseObj.GetCharBody().AddForce(vForce * afTimeStep);
		}
		else
		{
			mBaseObj.SetVarVector3f("CollisionPushForce", 0);
		}
		
		///////////////
		// Check if player is backing off
		// Doing this here since it needs to be updated in multiple states
		if (mbHunt_ProtectingFood)
		{
			float fPlayerDistFromFood = (mvHunt_StartPos - mBaseObj.GetPlayerFeetPos()).Length();
			if (fPlayerDistFromFood > mfHunt_PrevPlayerDistFromFood)
				mfHunt_PlayerRetreatCount += afTimeStep;
			else
				mfHunt_PlayerRetreatCount = cMath_Max(mfHunt_PlayerRetreatCount-afTimeStep*3.0f, 0.f);
				
			mfHunt_PrevPlayerDistFromFood = fPlayerDistFromFood;
		}

		cSystem_ProfileEnd("Rat Update");
	}
	
	//------------------------------------------------------------
	
	void OnVariableUpdate(float afDeltaTime)
	{
		cSystem_ProfileStart("Rat VariableUpdate");

		UpdateSmellPlayer(afDeltaTime);
		UpdateSmellFood(afDeltaTime);

		cSystem_ProfileEnd("Rat VariableUpdate");
	}

	//------------------------------------------------------------
	
	void OnPhysicsUpdate(float afTimeStep)
	{
		
	}

	//------------------------------------------------------------

	void ResetProperties()
	{
	}

	//------------------------------------------------------------

	void OnSetActive(bool abX)
	{
		if (abX) mpMover.SetUseMoveStateAnimations(true);
	}
	
	//------------------------------------------------------------	
	
	void HitByProp(float afAmount, float afMass, iPhysicsBody@ apBody, cLuxProp@ apProp)
	{	
		mbLastHitByHeavyProp = apBody.GetMass() >= 10.0f;
		
		if (mbLastHitByHeavyProp && apProp !is null && apProp.GetClassName() == "cScrPropHeavyThrowable")
		{
			int lCollideObjBreakCount = apProp.GetVarInt("BreakCount")+1;
			apProp.SetVarInt("BreakCount", lCollideObjBreakCount);
			
			if (lCollideObjBreakCount >= 4)
			{
				apProp.SetDisableBreakable(false);
				apProp.Break();
			}
		}
	}
	
	//------------------------------------------------------------
	
	void GiveDamage(iPhysicsBody@ apBody, const cVector3f &in avOrigin, const cVector3f &in avHitPos, cLuxDamageProperties@ apDamageProps)
	{
		/////////////////
		// State check
		if (mpStateMachine.GetCurrentState() == eRatState_Dead)
			return;
		
		/////////////////
		// Setup vars
		int lCurrentState = mpStateMachine.GetCurrentState();
		bool bDead = mBaseObj.GetHealth() <= 0.f;
		bool bShouldRetreat = false;
		bool bCheckShouldIgnoreDamageArea = false;
		
		int lHitboxBodyId = -1;
		if (apBody !is null)
		{
			for (int i = 0; i < mBaseObj.GetHitboxBodyNum(); ++i)
			{
				if (apBody is mBaseObj.GetHitboxBody(i))
				{
					lHitboxBodyId = i;
					break;
				}
			}
		}
		
		mlDead_HitboxBodyId = lHitboxBodyId;
		mfDead_HitForce = apDamageProps.mfForce;
		mfDead_HitMaxImpulse = apDamageProps.mfMaxImpulse;
		mvDead_HitPosition = avHitPos;
		mvDead_HitOrigin = avOrigin;
		msDead_Anim = "";
		mbDead_AnimIsPose = false;
		
		/////////////////
		// Gun
		if (apDamageProps.mDamageType == eDamageType_Gun)
		{			
			
			// Ugly check to see if it's a shotgun causing damage or just the regular gun
			if (Item_GetHeldType(eItemHandlerHand_Right) == "Shotgun") {
                //cLux_AddDebugMessage("HEALTH REMAINING: " + mBaseObj.GetHealth());
				cLux_AddDebugMessage("(" + mBaseObj.GetName() + ") Shot by shotgun!");
				Achievement_Unlock(eAchievement_Ratter);
				mfDead_HitForce *= 2.0f;			
				//mpStateMachine.ChangeState(eRatState_Dead);
				
							float fAngle = mBaseObj.GetAngleToPos2D(mvDead_HitOrigin);
			cVector3f vRight = cMath_MatrixMul(cMath_MatrixRotateY(mBaseObj.GetCharBody().GetYaw()), cVector3f_Right);
			float fRightDot = cMath_Vector3Dot(cMath_Vector3Normalize(mvDead_HitOrigin-mBaseObj.GetPosition()), vRight);
			
			if (fAngle < cMath_PiDiv4)
				msDead_Anim = gsRatAnim_Shot_Front;
			else if (fAngle > cMath_Pi*0.75f)
				msDead_Anim = gsRatAnim_Shot_Back;
			else if (fRightDot > 0)
				msDead_Anim = gsRatAnim_Shot_Right;
			else
				msDead_Anim = gsRatAnim_Shot_Left;
				
			mbDead_AnimIsPose = true;
			}
				
			cLux_AddDebugMessage("(" + mBaseObj.GetName() + ") Shot by gun!");
			cLux_AddDebugMessage("HEALTH REMAINING: " + mBaseObj.GetHealth());
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Shot by gun!");
		}
		
		/////////////////
		// Grenade
		else if (apDamageProps.mDamageType == eDamageType_Grenade)
		{
			mfDead_HitForce *= 3.f;			
			//mpStateMachine.ChangeState(eRatState_Dead);
			
			////////////////////////
			// Give achivement if enough rats were killed by this grenade
			tID idPrevGrenade = cScript_GetGlobalVarID("PrevRatGrenade");
			int lRatsKilledCount = cScript_GetGlobalVarInt("RatGrenadeKillCount") + 1;
			if (idPrevGrenade != apDamageProps.m_idSource)
				lRatsKilledCount = 1;
			
			if (lRatsKilledCount >= glRat_ExtremeRatterGoal)
				Achievement_Unlock(eAchievement_ExtremeRatter);
			
			cScript_SetGlobalVarInt("RatGrenadeKillCount", lRatsKilledCount);
			cScript_SetGlobalVarID("PrevRatGrenade", apDamageProps.m_idSource);
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + "Killed by grenade!");
		}
		
		/////////////////
		// Fire
		else if (apDamageProps.mDamageType == eDamageType_Fire)
		{
			if (bDead)
			{
				msDead_Anim = gvRatAnim_Death[cMath_RandRectl(0, gvRatAnim_Death.length()-1)];
				mpStateMachine.ChangeState(eRatState_Dead);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + "Killed by fire!");
			}
			else
			{
                cLux_AddDebugMessage("FIRE TRIGGER");
				bCheckShouldIgnoreDamageArea = true;
				//DoctorD edit: made it not retreat by fire
                bShouldRetreat = false;
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + "Hurt by fire!");
			}
		}
		
		/////////////////
		// Gas
		else if (apDamageProps.mDamageType == eDamageType_Gas)
		{
			if (bDead)
			{
				msDead_Anim = gvRatAnim_Death[cMath_RandRectl(0, gvRatAnim_Death.length()-1)];
				mpStateMachine.ChangeState(eRatState_Dead);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + "Killed by gas!");
			}
			else
			{
				bCheckShouldIgnoreDamageArea = true;
				bShouldRetreat = false;
				if (lCurrentState == eRatState_Eat)
				{
					RatHandler_SetFoodThreatTime(m_idEat_FoodEntityId, 75);
				}
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + "Hurt by gas!");
			}
		}
		
		/////////////////
		// Ignore damage area?
		// (Already inside the damage area, ignore it so it doesn't mess with pathfinding!)
		if (bCheckShouldIgnoreDamageArea)
		{				
			iPhysicsBody@ pBody = cLux_ID_Body(apDamageProps.m_idSource);
			
			bool bIgnoreDamageArea = pBody !is null &&
									 Blackboard_GetIsBodyDamageArea(pBody) &&
									 mvIgnoredDamageAreas.find(apDamageProps.m_idSource) == -1;
			
			if (bIgnoreDamageArea)
			{
				mvIgnoredDamageAreas.push_back(apDamageProps.m_idSource);
				mpPathfinder.RemovePathBlockerBody(apDamageProps.m_idSource);
			}
		}		
		
		/////////////////
		// Retreat
		if (bShouldRetreat)
		{
			if (lCurrentState == eRatState_Retreat)
			{
				mpMover.SetSpeedState(eRatSpeed_Run);
			}
			else
			{
				//Retreat(eRatSpeed_Run, false, true);
			}
		}
	}
	
	//------------------------------------------------------------
	
	void OnPathFindingResult(bool abSuccessful)
	{
		////////////////////
		// Escape if high fail count!
		// (TODO: This is a hack to prevent this function getting called multiple times per frame when 
		//  the rat can't find a path! Needs a proper fix.)		
		if (mlPathFindingResultFailCount > 1)
			return;
		
		////////////////////
		// Setup vars
		int lCurrentState = mpStateMachine.GetCurrentState();
		
		////////////////////
		// No path found!
		if (abSuccessful == false)
		{
			////////////////////
			// Try to retreat
			if (lCurrentState == eRatState_Hunt || 
				lCurrentState == eRatState_FindFood ||
				lCurrentState == eRatState_TrackBloodTrail)
			{
				Retreat(eRatSpeed_Run, false, false);				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path found, trying to retreat!", false, true);		
			}
			
			////////////////////
			// Increase count
			++mlPathFindingResultFailCount;			
		}
		
		////////////////////
		// Path found!
		else
		{
			mlPathFindingResultFailCount = 0;
		}
	}
	
	//------------------------------------------------------------

	//} END GENERAL

	//------------------------------------------------------------

	//} END MAIN FUNCTIONS

	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// HELPERS
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	tString SpeedStateToString(int alState)
	{
		switch (alState)
		{
			case eRatSpeed_SlowWalk: return "slow walk";
			case eRatSpeed_Walk: return "walk";
			case eRatSpeed_Run: return "run";
			case eRatSpeed_Attack: return "attack";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	tString StateToString(int alState)
	{
		switch (alState)
		{
			case eRatState_Eat: return "Eat";
			case eRatState_FindFood: return "FindFood";
			case eRatState_Retreat: return "Retreat";
			case eRatState_GoToHole: return "GoToHole";
			case eRatState_Emerge: return "Emerge";
			case eRatState_Hunt: return "Hunt";
			case eRatState_Attack: return "Attack";
			case eRatState_PostAttack: return "PostAttack";
			case eRatState_TrackBloodTrail: return "TrackBloodTrail";
			case eRatState_Smell: return "Smell";
			case eRatState_Dead: return "Dead";
			case eRatState_Threatened: return "Threatened";
			case eRatState_WanderThenHide: return "WanderThenHide";
		}
		
		return "";
	}
	
	//------------------------------------------------------------
	
	void UpdateMovingToHole(float afTimeStep)
	{
		///////////////////
		// Go to hole
		if (msMovingToHoleState == "GoToHole")
		{
			float fDistSqr = GetDistanceToPosSqr2D(mvTargetHoleFeetPos);
			
			///////////////////
			// Slow down when getting close
			if (fDistSqr < 4.f * 4.f && mpMover.GetSpeedState() != eRatSpeed_Walk)
			{
				mpMover.SetSpeedState(eRatSpeed_Walk);
			}
			
			///////////////////
			// Enter hole if near!
			if (fDistSqr < 0.5f * 0.5f)
			{
				msMovingToHoleState = "EnterHole";
				mfEnterHoleTime = 0;
				
				mpMover.SetSpeedState(eRatSpeed_Walk);
				SetCollide(false);
			}
		}
		
		///////////////////
		// Enter hole
		// TODO: Animation for this!
		else if (msMovingToHoleState == "EnterHole")
		{
			mfEnterHoleTime += afTimeStep;
			
			if (mpPathfinder.IsMoving()==false)
			{
				iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
				mpMover.TurnToPos(mvTargetHolePos);
				
				float fTurnGoalYaw = mpMover.GetTurnGoalAngles().y;
				float fAngleDist = cMath_Abs(cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fTurnGoalYaw));
				
				if (fAngleDist > cMath_PiDiv4)
					pCharBody.StopMovement();
				else
					pCharBody.Move(eCharDir_Forward, 1.f);
			}
			
			if (GetDistanceToPosSqr2D(mvTargetHolePos) < 0.2f * 0.2f || mfEnterHoleTime > 3.0f)
			{
				mBaseObj.SetActive(false);				
				
				tID idRat = mBaseObj.GetID();
				RatHandler_AddHidingRat(idRat, m_idTargetHole);
				RatHandler_SetRatIgnoresDamageAreas(idRat, false);
				
				////////////////////
				// Allow blood trail tracking
				mbAllowTrackBloodTrail = true;
				
				////////////////////
				// Reset ignored damage areas
				// (If they still exist!)
				for (uint i = 0; i < mvIgnoredDamageAreas.size(); ++i)
				{
					tID idBody = mvIgnoredDamageAreas[i];
					iPhysicsBody@ pBody = cLux_ID_Body(idBody);
					
					if (pBody is null) continue;
					
					mpPathfinder.AddPathBlockerBody(idBody);
				}
				
				mvIgnoredDamageAreas.resize(0);
			}
		}
	}
	
	//------------------------------------------------------------
	
	bool MovingToHole_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (msMovingToHoleState == "GoToHole")
			{
				if (GetDistanceToPosSqr2D(mvTargetHoleFeetPos) > 0.5f * 0.5f)
				{
					mpPathfinder.MoveTo(mvTargetHoleFeetPos, 1.f, false);
					return true;
				}
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	bool GetIsHoleBlocked(tID a_idHole, tID &out a_iBlockingBody)
	{
		cLuxArea@ pArea = cLux_ID_Area(a_idHole);
		if (pArea is null) return false;
		
		a_iBlockingBody = GhoulHole_GetBlockingBody(pArea.GetName());
		return a_iBlockingBody != tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	bool GetIsHoleBlocked(tID a_idHole)
	{
		cLuxArea@ pArea = cLux_ID_Area(a_idHole);
		if (pArea is null) return false;
		
		return GhoulHole_GetBlockingBody(pArea.GetName()) != tID_Invalid;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetMeshPositionOffset()
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		cMatrixf mtxRot = cMath_MatrixRotateY(pCharBody.GetYaw());
		cVector3f vEntityOffset = pCharBody.GetEntityOffset().GetTranslation();
		vEntityOffset.y = 0.f;
				
		return cMath_MatrixMul(mtxRot, vEntityOffset);
	}
	
	//------------------------------------------------------------
	
	tString GetRandomAnim(const array<tString> &in avArray)
	{
		return avArray[cMath_RandRectl(0, avArray.length()-1)];
	}
	
	//------------------------------------------------------------
	
	void SetCollide(bool abX)
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null) return;
		
		pCharBody.SetTestCollision(abX);
		
		/////////////////
		// Clear old velocity
		if (abX)
		{
			pCharBody.StopMovement();
		}
	}
	
	//------------------------------------------------------------
	
	bool mbMoveTo_UpdatingSuccessfulPath = false;
	cVector3f mvMoveTo_Target;
	float mfMoveTo_UpdateFreq;
	bool mbMoveTo_ExactStopAtEnd;
	
	//////////////////////////////////
	// Use this instead of the pathfinder's MoveTo in cases where
	// the rats try to run through walls
	void MoveToPos_ForceUpdate(const cVector3f avPos, float afUpdateFreq, bool abExactStopAtEnd)
	{
		mvMoveTo_Target = avPos;
		mfMoveTo_UpdateFreq = afUpdateFreq;
		mbMoveTo_ExactStopAtEnd = abExactStopAtEnd;
		
		mpPathfinder.MoveTo(mvMoveTo_Target, mfMoveTo_UpdateFreq, mbMoveTo_ExactStopAtEnd, "MoveToCallback");
		mbMoveTo_UpdatingSuccessfulPath = false;
	}
	
	void MoveToCallback(bool abSuccesful)
	{
		if (mbMoveTo_UpdatingSuccessfulPath && !abSuccesful)
		{
			mpPathfinder.Stop();
			mpPathfinder.MoveTo(mvMoveTo_Target, mfMoveTo_UpdateFreq, mbMoveTo_ExactStopAtEnd, "MoveToCallback");
			return;
		}
		mbMoveTo_UpdatingSuccessfulPath = abSuccesful;
	}
	
	//------------------------------------------------------------

	//} END HELPERS

	//------------------------------------------------------------

	/////////////////////////////////////////
	// GLOBAL FUNCS
	//{//////////////////////////////////////
		
	//------------------------------------------------------------
	
	void _Global_GetSpawnAtPos()
	{
		cScript_SetGlobalReturnBool(mbSpawnAtPos);
	}
	
	//------------------------------------------------------------
	
	void _Global_EmergeToFood()
	{
		tID idEmergeHole = cScript_GetGlobalArgID(0);
		tID idTarget = cScript_GetGlobalArgID(1);
		
		bool bRet = Emerge_Setup(idEmergeHole, idTarget, eRatEmergeType_Food);
		if (bRet)
		{
			mBaseObj.SetActive(true);
			mpStateMachine.ChangeState(eRatState_Emerge);		
		}	
		
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_EmergeToWander()
	{
		tID idEmergeHole = cScript_GetGlobalArgID(0);
		tID idTarget = cScript_GetGlobalArgID(1);
		
		bool bRet = Emerge_Setup(idEmergeHole, idTarget, eRatEmergeType_Wander);
		if (bRet)
		{
			mBaseObj.SetActive(true);
			mpStateMachine.ChangeState(eRatState_Emerge);		
		}	
		
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_EmergeToBloodTrail()
	{
		tID idEmergeHole = cScript_GetGlobalArgID(0);
		tID idTarget = cScript_GetGlobalArgID(1);
		
		bool bRet = Emerge_Setup(idEmergeHole, idTarget, eRatEmergeType_BloodTrail);
		if (bRet)
		{
			mBaseObj.SetActive(true);
			mpStateMachine.ChangeState(eRatState_Emerge);		
		}	
		
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_Retreat()
	{
		bool bRet = false;
		bool bRun = cScript_GetGlobalArgBool(0);
		bool bScared = cScript_GetGlobalArgBool(1);
		bool bSensesActive = cScript_GetGlobalArgBool(2);
		tID idTargetHole = cScript_GetGlobalArgID(3);
		bool bFlame = cScript_GetGlobalArgBool(4);
		
		if (mpStateMachine.GetCurrentState() != eRatState_Retreat)
		{
			bRet = true;
			Retreat(bRun ? eRatSpeed_Run : eRatSpeed_Walk, bScared, bSensesActive, idTargetHole, bFlame ? eRatRetreatReason_Flame : eRatRetreatReason_Default);
		}
		
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_DelayedFoodRetreat()
	{
		float fDelay = cScript_GetGlobalArgFloat(0);
		mBaseObj.Timer_Add("Timer_DelayedFoodRetreat", fDelay, "OnTimer_DelayedFoodRetreat");
	}
	
	void OnTimer_DelayedFoodRetreat(uint64 alTimer)
	{
		//Retreat(eRatSpeed_Walk, false, true);
	}
	
	//------------------------------------------------------------
	
	void _Global_Eat()
	{
		m_idEat_FoodEntityId = cScript_GetGlobalArgID(0);
		if (mpStateMachine.GetCurrentState() != eRatState_Eat)
		{
			mpStateMachine.ChangeState(eRatState_Eat);
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_SetEatTimeoutActive()
	{
		mbEat_TimeoutActive = cScript_GetGlobalArgBool(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_Attack()
	{
		RatHandler_DoRatAttack();
		
		mbAttack_Fast = cScript_GetGlobalArgBool(0);
		mbAttack_Warning = cScript_GetGlobalArgBool(1);
		mbHunt_ProtectingFood = mbAttack_Warning;
		mpStateMachine.ChangeState(eRatState_Attack);
	}
	
	//------------------------------------------------------------
	
	void _Global_TrackBloodTrail()
	{
		bool bRet = false;
		int lState = mpStateMachine.GetCurrentState();
		tID idEntity = cScript_GetGlobalArgID(0);
		
		if ((mBaseObj.GetSensesActive() && GetAllowTrackBloodTrail()) && 
			((lState == eRatState_FindFood && mbFindFood_SensesActive) || 
			(lState == eRatState_WanderThenHide && mbWanderThenHide_SensesActive) ||
			lState == eRatState_GoToHole ||
			(lState == eRatState_Retreat && mbRetreat_SensesActive)))
		{
			bRet = true;
			m_idTrackBloodTrail_CurrentTrailId = idEntity;
			mpStateMachine.ChangeState(eRatState_TrackBloodTrail);
		}
		
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_Threatened()
	{
		bool bRet = false;
		
		/////////////////////////////////
		// If already retreating skip entering threatened state
		int lState = mpStateMachine.GetCurrentState();
		//DoctorD edit: keep this in mind, may have to modify or comment
        if (lState == eRatState_Retreat)
		{
			///////////
			// Run away
			if (mlRetreat_SpeedState != eRatSpeed_Run)
			{
				mlRetreat_SpeedState = eRatSpeed_Attack;
				mbRetreat_Scared = false;
				mbRetreat_SensesActive = true;
			}
			
			cScript_SetGlobalReturnBool(bRet);
			return;
		}
		
		////////////////
		// Enter thretened state
		bRet = false;
		Threatened();
		cScript_SetGlobalReturnBool(bRet);
	}
	
	//------------------------------------------------------------
	
	void _Global_InThreatReactionRange()
	{
		cScript_SetGlobalReturnBool(Threatened_GetIsInReactionDistance());
	}
	
	//------------------------------------------------------------
	
	void _Global_GetPrevClosestBloodTrail()
	{
		cScript_SetGlobalReturnID(m_idPrevClosestBloodTrail);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetPrevClosestBloodTrail()
	{
		m_idPrevClosestBloodTrail = cScript_GetGlobalArgID(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_ResetHungerTimer()
	{
		mfHungerTimer = 0;
	}
	
	//------------------------------------------------------------
	
	void _Global_Debug()
	{
	}
	
	//------------------------------------------------------------

	//} END GLOBAL

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// RAT SPECIFIC CODE
	//=======================================
	//{//////////////////////////////////////

	//===========================================================	
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// RAT UPDATES
	//{///////////////////////////////////////

	//------------------------------------------------------------
	
	void UpdateSmellPlayer(float afDeltaTime)
	{
		////////////////////////
		// Setup vars
		int lState = mpStateMachine.GetCurrentState();
		
		////////////////////////
		// Time
		mfSmellPlayerCount -= afDeltaTime;
		if (mfSmellPlayerCount > 0.f)
			return;
			
		float fSmellTimeMul = lState == eRatState_TrackBloodTrail ? 0.1f : 1.f;
		mfSmellPlayerCount = cMath_RandRectf(gfRat_SmellPlayerTimeMin, gfRat_SmellPlayerTimeMax) * fSmellTimeMul;
		
		////////////////////////
		// State check
		if (lState == eRatState_Dead ||
			lState == eRatState_Smell ||
			lState == eRatState_Hunt ||
			lState == eRatState_Attack ||
			lState == eRatState_PostAttack ||
			lState == eRatState_Emerge ||
			lState == eRatState_Threatened ||
			lState == eRatState_Eat ||
			lState == eRatState_StalkPlayer ||
			(lState == eRatState_FindFood && mbFindFood_SensesActive == false) ||
			(lState == eRatState_Retreat && mbRetreat_SensesActive == false) ||
			(lState == eRatState_WanderThenHide && mbWanderThenHide_SensesActive == false) ||
			mBaseObj.GetSensesActive() == false ||
			RatHandler_GetRatsAreAggressive() == false)
		{
			return;
		}
				
		////////////////////////
		// Get smell radius
		float fPlayerHealth = cLux_GetPlayer().GetHealth();
		float fSmellRadiusMul = cMath_Max(1.f - fPlayerHealth, 0.5f);
		float fSmellRadius = gfRat_SmellPlayerRadius * fSmellRadiusMul;
		
		////////////////////////
		// Player inside radius?
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		float fDistY = cMath_Abs(vPlayerFeetPos.y - mBaseObj.GetCharBody().GetFeetPosition().y);
		float fDistSqr = GetDistanceToPosSqr2D(vPlayerFeetPos);
		
		if (fDistSqr > fSmellRadius * fSmellRadius || fDistY > 1.5f)
			return;
			
		////////////////////////
		// Smell player if they're bleeding, or rat is tracking blood!
		bool bPlayerBleeding = Player_GetIsBleeding() && RatHandler_GetBloodTrailNum() > 0;	
		if (bPlayerBleeding || lState == eRatState_TrackBloodTrail)
		{
			mbSmell_SmellingPlayer = bPlayerBleeding;
			mvSmell_SmellPos = mBaseObj.GetPlayerFeetPos();
			mpStateMachine.ChangeState(eRatState_Smell);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateSmellFood(float afDeltaTime)
	{
		////////////////////////
		// Check if hungry
		if (mfHungerTimer > 0.0f)
		{
			mfHungerTimer -= afDeltaTime;
			return;
		}
		
		////////////////////////
		// Time
		mfSmellFoodCount -= afDeltaTime;
		if (mfSmellFoodCount > 0.f)
			return;
			
		mfSmellFoodCount = cMath_RandRectf(gfRat_SmellFoodTimeMin, gfRat_SmellFoodTimeMax);
		
		////////////////////////
		// Check states that should never be distracted by food
		int lState = mpStateMachine.GetCurrentState();
		if (lState == eRatState_Dead ||
			lState == eRatState_Smell ||
			lState == eRatState_Hunt ||
			lState == eRatState_Attack ||
			lState == eRatState_PostAttack ||
			lState == eRatState_Emerge ||
			lState == eRatState_Threatened ||
			(lState == eRatState_Retreat && mbRetreat_SensesActive == false) ||
			(lState == eRatState_WanderThenHide && mbWanderThenHide_SensesActive == false))
		{
			return;
		}
		
		////////////////////////
		// Get closest food
		tID idFood = RatHandler_GetFreeFoodEntityId(mBaseObj.GetID(), true, true);
		if (idFood == tID_Invalid) return;
		
		if (mpPathfinder.BuildPathNodeArrayFromTo(mBaseObj.GetPosition(), cLux_ID_Entity(idFood).GetPosition())==false)
			return;
		
		if (Achievement_GetUnlocked(eAchievement_CulinarySpecialist) == false && mpStateMachine.GetCurrentState() == eRatState_Eat && RatHandler_GetRatFoodIsThrownMeat(idFood))
			Achievement_Unlock(eAchievement_CulinarySpecialist);
		
		m_idFindFood_FoodEntityId = idFood;
		mpStateMachine.ChangeState(eRatState_FindFood);
	}
	
	//------------------------------------------------------------
	
	void UpdateQuickTurn(float afTimeStep)
	{		
		int lState = mpStateMachine.GetCurrentState();
		
		////////////////////////
		// State check
		if (lState == eRatState_Dead ||
			lState == eRatState_Attack ||
			lState == eRatState_PostAttack ||
			lState == eRatState_Emerge)
		{
			return;
		}
		
		////////////////////
		// Setup
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		cMeshEntity@ pMeshEnt = mBaseObj.GetMeshEntity();
		cLuxMap@ pMap = mBaseObj.GetMap();
		iPhysicsWorld@ pPhysicsWorld = pMap.GetPhysicsWorld();
		
		if (pCharBody is null) return;
		if (pMeshEnt is null) return;
		if (pPhysicsWorld is null) return;
		
		////////////////////
		// Play turn around anim?
		if (mbPlayQuickTurnAnim == false && mpPathfinder.IsMoving())
		{
			////////////////////
			// Long enough since last?
			if (mlQuickTurnTimeStamp > 0 && 
				pMap.GetElapsedTime(mlQuickTurnTimeStamp) < gfRat_MinTimeBetweenQuickTurns)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Valid goal?
			float fGoalYaw = mpMover.GetTurnGoalAngles().y;
			if (cMath_Abs(fGoalYaw) == 0.f)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
				
			////////////////////
			// Within angle dist?
			float fAngleDist = cMath_Abs(cMath_GetAngleDistanceRad(pCharBody.GetYaw(), fGoalYaw));
			if (fAngleDist < gfRat_PlayTurnAroundAnimMinAngle)
			{
				mfQuickTurnCount = 0.f;
				return;
			}
			
			////////////////////
			// Tried to turn around for long enough?
			mfQuickTurnCount += afTimeStep;
			if (mfQuickTurnCount < 0.1f)
				return;
			
			////////////////////
			// Won't collide if turning around?
			cVector3f vTurnOffset = GetMeshPositionOffset() + cVector3f(0.f, 0.05f, 0.f);
			cVector3f vBoneRootPos = pMeshEnt.GetBoneStateRoot().GetWorldPosition();
			vBoneRootPos.y = pCharBody.GetPosition().y;
			
			cMatrixf mtxTransform = cMath_MatrixTranslate(vBoneRootPos + vTurnOffset);
			
			cVector3f vPush;
			if (pPhysicsWorld.CheckShapeWorldCollision(vPush, pCharBody.GetCurrentShape(), mtxTransform, null, false, false, true, false))
			{
				mfQuickTurnCount = 0.f;
				return;
			}
				
			////////////////////
			// Play anim!
			mbPlayQuickTurnAnim = true;
			mfQuickTurnCount = 0.f;
			mlQuickTurnTimeStamp = pMap.GetTimeStamp();
						
			mpMover.PlayAnimation(gsRatAnim_TurnAround, 0.3f, false, false, "");
			mpMover.SetUseMoveStateAnimations(false);			
		}
		
		////////////////////
		// Turn around anim playing?
		if (mbPlayQuickTurnAnim)
		{
			////////////////////
			// Stop movement
			pCharBody.StopMovement();
			mpMover.StopTurning();
			
			////////////////////
			// Get anim
			cAnimationState@ pAnim = pMeshEnt.GetAnimationStateFromName(gsRatAnim_TurnAround);
			if (pAnim is null)
			{
				mbPlayQuickTurnAnim = false;
			}
			
			////////////////////
			// Anim over?
			else if (pAnim.IsOver())
			{
				mbPlayQuickTurnAnim = false;
				
				////////////////////
				// Orient and position char body!
				cVector3f vBoneRootPos = pMeshEnt.GetBoneStateRoot().GetWorldPosition();
				cVector3f vNewPos = vBoneRootPos + GetMeshPositionOffset();				
				float fNewYaw = pCharBody.GetYaw() + cMath_Pi;
				
				pCharBody.SetYaw(fNewYaw);
				pCharBody.SetFeetPosition(vNewPos, false);
				
				////////////////////
				// Play idle anim
				mpMover.PlayAnimation(gsRatAnim_Normal_Walk, 0.f, false, false, "");
				mpMover.SetUseMoveStateAnimations(true);
			}
		}
	}
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// RAT HELPERS
	//{////////////////////////////////

	//------------------------------------------------------------
	
	void SetRagdollActive(bool abX, float afFadeOutTime)
	{
		mpMover.SetUseMoveStateAnimations(abX == false);
		mBaseObj.SetRagdollActive(abX, afFadeOutTime);
	}
	
	//------------------------------------------------------------
	
	float GetPathDistanceToPos(const cVector3f &in avFrom, const cVector3f &in avTo)
	{
		if (mpPathfinder.BuildPathNodeArrayFromTo(avFrom, avTo))
			return mpPathfinder.GetPathNodeArrayFullLength();
		
		return -1.f;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetInnerHolePos(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		if (pHole is null) return cVector3f(0.f);
		
		cVector3f vHolePos = pHole.GetPosition();
		vHolePos.y = pHole.GetAreaBody().GetBoundingVolume().GetMin().y;
		cVector3f vHoleFwd = pHole.GetMatrix().GetTranspose().GetForward();
		
		return vHolePos + vHoleFwd * -1.25f;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetHoleGroundPos(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		if (pHole is null) return cVector3f(0.f);
		
		cVector3f vHolePos = pHole.GetPosition();
		vHolePos.y = pHole.GetAreaBody().GetBoundingVolume().GetMin().y;
		
		return vHolePos;
	}
	
	//------------------------------------------------------------
	
	float GetHoleAngle(tID a_idHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idHole);
		if (pHole is null) return 0.f;
		
		cVector3f vFwd = pHole.GetMatrix().GetTranspose().GetForward();
		float fAngle = cMath_GetAngleFromPoints3D(0.f, vFwd).y;
		
		return fAngle;
	}
	
	//------------------------------------------------------------
	
	float GetDistanceToPosSqr2D(const cVector3f &in avPos)
	{
		cVector3f vDelta = avPos - mBaseObj.GetCharBody().GetPosition();
		vDelta.y = 0.f;
		return vDelta.SqrLength();
	}
	
	//------------------------------------------------------------
	
	float GetDistanceToPosSqr(const cVector3f &in avPos)
	{
		cVector3f vDelta = avPos - mBaseObj.GetCharBody().GetPosition();
		return vDelta.SqrLength();
	}
	
	//------------------------------------------------------------
	
	void Retreat(eRatSpeed aSpeed, bool abScared, bool abSensesActive, tID a_idTargetHole = tID_Invalid, eRatRetreatReason aReason = eRatRetreatReason_Default)
	{
		mlRetreat_SpeedState = aSpeed;
		mbRetreat_Scared = abScared;
		mbRetreat_SensesActive = abSensesActive;
		m_idRetreat_TargetHole = a_idTargetHole;
		mRetreat_Reason = aReason;
		mpStateMachine.ChangeState(eRatState_Retreat);
	}
	
	//------------------------------------------------------------
	
	void GoToHole(tID a_idTargetHole)
	{
		m_idTargetHole = a_idTargetHole;
		mpStateMachine.ChangeState(eRatState_GoToHole);
	}
	
	//------------------------------------------------------------
	
	void GoToHole(bool abUseBestHole, tID a_idIgnoredHole)
	{
		GoToHole_SelectHole(abUseBestHole, a_idIgnoredHole);
		mpStateMachine.ChangeState(eRatState_GoToHole);
	}
	
	//------------------------------------------------------------
	
	void WanderThenHide(bool abSensesActive)
	{
		mbWanderThenHide_SensesActive = abSensesActive;
		mpStateMachine.ChangeState(eRatState_WanderThenHide);
	}
	
	//------------------------------------------------------------
	
	void Threatened()
	{
        //DoctorD Edit: changed state from threatened to attack
		if(!mBaseObj.Timer_Exists("ratk_attack_cooldown")){
            mpStateMachine.ChangeState(eRatState_Attack);
        }
        mBaseObj.Timer_Add("ratk_attack_cooldown", 1.0f, "", false, false);
	}
	
	//------------------------------------------------------------
	
	bool Backstep(bool abIgnoreCollision = false)
	{
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		if (pCharBody is null)
			return false;
			
		if (abIgnoreCollision)
		{
			pCharBody.Move(eCharDir_Forward, -1.f);
			return true;
		}
		
		/////////////////////
		// Setup collide shape
		float fRadius = pCharBody.GetSize().x*0.5f;
		cVector3f vPos = pCharBody.GetFeetPosition() + cVector3f(0.f, fRadius + 0.1f, 0.f) + pCharBody.GetForward() * -0.4f;
		cMatrixf mtxTransform = cMath_MatrixTranslate(vPos);
		
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		if (pPhysicsWorld is null)
			return false;
		
		if (mpBackstepCollideShape is null)
			@mpBackstepCollideShape = pPhysicsWorld.CreateSphereShape(fRadius, cMatrixf_Identity);
			
		///////////////
		// Sanity check
		if (mpBackstepCollideShape is null)
			return false;
		
		/////////////////////
		// Back up if space behind rat is free!
		iPhysicsBody@ pSkipBody = pCharBody.GetCurrentBody();
		if (pSkipBody is null)
			return false;
			
		cVector3f vPushVec;
		bool bCanBackstep = pPhysicsWorld.CheckShapeWorldCollision(vPushVec, mpBackstepCollideShape, mtxTransform, pSkipBody, false, false, true, false) == false;
		if (bCanBackstep)
			pCharBody.Move(eCharDir_Forward, -1.f);
			
		return bCanBackstep;
	}
	
	//------------------------------------------------------------
	
	void DestroyBackstepCollideShape()
	{
		if (mpBackstepCollideShape !is null)
		{
			mBaseObj.GetMap().GetPhysicsWorld().DestroyShape(mpBackstepCollideShape);
			@mpBackstepCollideShape = null;
		}
	}
	
	//------------------------------------------------------------
	
	void ReactToGunshot(const cVector3f &in avPos)
	{
		/////////////////////
		// Los check
		cVector3f vStart = mBaseObj.GetCharBody().GetFeetPosition() + cVector3f(0.f, 0.5f, 0.f);
		cVector3f vEnd = avPos + cVector3f(0.f, 0.5f, 0.f);
		
		if (cLux_CheckLineOfSight(vStart, vEnd, false, true, null) == false)
			return;			
			
		/////////////////////
		// Retreat or attack?
		switch (mpStateMachine.GetCurrentState())
		{
			case eRatState_Retreat:
				mpMover.SetSpeedState(eRatSpeed_Run);
				break;
			case eRatState_Eat:
				mpStateMachine.AddTimer("ReactToGunShot", cMath_RandRectf(0.1, 0.75));
                mpStateMachine.ChangeState(eRatState_Attack);
				break;
			case eRatState_Hunt:
				mpStateMachine.ChangeState(eRatState_Hunt);
				break;
			default:
				//Retreat(eRatSpeed_Run, true, false);
                mpStateMachine.ChangeState(eRatState_Attack);
				break;
		}
	}
	
	//------------------------------------------------------------
	
	bool GetAllowTrackBloodTrail()
	{
		return mbAllowTrackBloodTrail && RatHandler_GetRatsAreAggressive();
	}
	
	//------------------------------------------------------------
	
	//} END RAT HELPERS

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// STATES
	//=======================================
	/////////////////////////////////////////

	//===========================================================

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: DEFAULT
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Default_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Default ------");
	}
	
	//------------------------------------------------------------
	
	void State_Default_Leave() {}	
	void State_Default_Update(float afTimeStep) {}

	//------------------------------------------------------------

	bool State_Default_Message(int alMessageId)
	{
		/////////////////////
		// Setup vars
		int lCurrentState = mpStateMachine.GetCurrentState();
		
		/////////////////////
		// Stuck counter
		if (alMessageId == eLuxEntityMessage_StuckCounterIsAtMax)
		{
			bool bSenses = true;
			if (mpStateMachine.GetCurrentState()==eRatState_WanderThenHide)
				bSenses = mbWanderThenHide_SensesActive;
			if (mpStateMachine.GetCurrentState()==eRatState_Retreat)
				bSenses = mbRetreat_SensesActive;
			
			WanderThenHide(bSenses);
			return true;
		}

		/////////////////////
		// Hit by prop
		else if (alMessageId == eLuxEntityMessage_HitByProp)
		{		
            cLux_AddDebugMessage("HIT BY PROP");
			if (lCurrentState == eRatState_Retreat)
			{
				mpMover.SetSpeedState(eRatSpeed_Run);
				return true;
			}
			/*
			float fHitSpeed = mpStateMachine.GetCurrentMessageData().mvX.x;
			if (mbLastHitByHeavyProp == false || fHitSpeed < 1.f)
			{
				if (lCurrentState == eRatState_Eat)
					//Eat_TriggerAlert();
                    
				return false;	
			}
             */
            mpStateMachine.ChangeState(eRatState_Hunt);
			//Retreat(eRatSpeed_Run, false, true);
		}
			
		/////////////////////
		// Player fired gun
		else if (alMessageId == eCustomEntityMessage_PlayerShotGun)
		{
			/////////////////////
			// Setup vars
			bool bReact = false;
			cVector3f vPlayerPos = mBaseObj.GetPlayerFeetPos();

			/////////////////////
			// Too far away?
			if (GetDistanceToPosSqr(vPlayerPos) > gfRat_GunShotPlayerAttackMinDistSqr)
			{
				return true;
			}
			
			//////////////////
			// React
			ReactToGunshot(vPlayerPos);			
		
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player shot gun, retreat or attack!");
		}
		
		/////////////////////
		// Bullet impact
		else if (alMessageId == eCustomEntityMessage_BulletImpact)
		{
			/////////////////////
			// Setup vars
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;			
			
			float fMinDistSqr = gfRat_BulletImpactAttackMinDistSqr;
			if (lCurrentState == eRatState_Hunt || lCurrentState == eRatState_Attack)
				fMinDistSqr *= 0.2f;
			
			/////////////////////
			// Impact pos too far?
			if (GetDistanceToPosSqr(vPos) > fMinDistSqr)
			{
				return true;
			}		
			
			//////////////////
			// React
			ReactToGunshot(vPos);					
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Gun impact near, retreat or attack!");
		}
		
		/////////////////////
		// Grenade/molotov impact
		else if (alMessageId == eCustomEntityMessage_Explosion ||
				 alMessageId == eCustomEntityMessage_MolotovImpact)
		{			
            /*
			/////////////////////
			// Setup vars
			cVector3f vImpactPos = mpStateMachine.GetCurrentMessageData().mvX;
			float fDistSqr = GetDistanceToPosSqr(vImpactPos);			
			
			float fMinDistSqr = gfRat_GrenadeRetreatMinDistSqr;
			if (alMessageId == eCustomEntityMessage_MolotovImpact)
				fMinDistSqr = gfRat_MolotovRetreatMinDistSqr;
				
			if (fDistSqr >= fMinDistSqr) return true;
				
			/////////////////////
			// Los check
			cVector3f vLosStartPos = mBaseObj.GetPosition() + cVector3f(0.f, 0.5f, 0.f);
			cVector3f vLosEndPos = vImpactPos + cVector3f(0.f, 0.5f, 0.f);
			
			if (cLux_CheckLineOfSight(vLosStartPos, vLosEndPos, false, true, null) == false)
				return true;
			
			/////////////////////
			// Retreat
			if (lCurrentState == eRatState_Retreat)
			{
				mpMover.SetSpeedState(eRatSpeed_Run);
			}
			else
			{
				//Retreat(eRatSpeed_Run, true, false, tID_Invalid, eRatRetreatReason_Flame);
                mpStateMachine.ChangeState(eRatState_Hunt);
				if (lCurrentState == eRatState_Eat)
				{
					RatHandler_SetFoodThreatTime(m_idEat_FoodEntityId, 120);
				}
			}
			*/
            RatHandler_SetRatIgnoresDamageAreas(mBaseObj.GetID(), true);
            mpStateMachine.ChangeState(eRatState_Hunt);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Grenade/molotov impact nearby, pursue!");
		}
		
		/////////////////////
		// Flare burning
		else if (alMessageId == eCustomEntityMessage_FlareBurning)
		{			
            /*
			/////////////////////
			// Setup vars
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			float fDistSqr = GetDistanceToPosSqr(vPos);			
			
			float fMinDistSqr = gfRat_FlareRetreatMinDistSqr;
			
			if (fDistSqr >= fMinDistSqr) return true;
				
			/////////////////////
			// Los check
			cVector3f vLosStartPos = mBaseObj.GetPosition() + cVector3f(0.f, 0.5f, 0.f);
			cVector3f vLosEndPos = vPos + cVector3f(0.f, 0.5f, 0.f);
			
			if (cLux_CheckLineOfSight(vLosStartPos, vLosEndPos, false, true, null) == false)
				return true;
			
			/////////////////////
			// Retreat
			if (lCurrentState == eRatState_Retreat)
			{
				mpMover.SetSpeedState(eRatSpeed_Run);
			}
			else
			{
				//Retreat(eRatSpeed_Run, false, true);
                
				if (lCurrentState == eRatState_Eat)
				{
					RatHandler_SetFoodThreatTime(m_idEat_FoodEntityId, 120);
				}
			}
			*/
            
            mpStateMachine.ChangeState(eRatState_Hunt);
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Flare burning nearby, retreat!");
		}
		
		////////////
		// Attracted
		else if (alMessageId == eCustomEntityMessage_AttractAgent)
		{
			if (mbAttracted_Enabled == false) return true;
			mvMeatAttractPos = mpStateMachine.GetCurrentMessageData().mvX;
			//mpStateMachine.ChangeState(eRatState_FindFood);
			cLux_AddDebugMessage(mBaseObj.GetName() + " ************************ [Agent_Rat] Food dropped! Yey! ************************ ");
		}
		
		/////////////////////
		// Near door
		else if (alMessageId == eLuxEntityMessage_NearDoor)
		{
			bool bOpen = mpStateMachine.GetCurrentMessageData().mlX == 1;
			tID idDoor = mpStateMachine.GetCurrentMessageData().mID;
			cLuxProp@ pDoor = cLux_ID_Prop(idDoor);
			tString sDoorName = pDoor !is null ? pDoor.GetName() : "";
			
			if (pDoor is null) return true;
			if (pDoor.GetHealth() <= 0.f && pDoor.GetBreakActive()) return true;
			if (SwingDoor_GetOpenAmount(sDoorName) > 0.3f) return true;
			
			cLux_AddDebugMessage("Give up");
			Retreat(eRatSpeed_Walk, false, false);
		}

		return false;
	}
	
	//------------------------------------------------------------

	//} END DEFAULT

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: EAT
	//{////////////////////////////////
	
	//-----------------------------------------------------------
	
	bool mbEat_IsAlerted = false;
	float mfEat_AlertCount = 0.f;
	float mfEat_TimeUntilAlert = gfRat_AlertTimeMax;
	float mfEat_TimeUntilUnalert = gfRat_UnalertTimeMax;
	tID m_idEat_FoodEntityId = tID_Invalid;
	float mfEat_PrevPlayerDist = 10000; 
	bool mbEat_TimeoutActive = true;
	float mfEat_AttackTimer = 0;
	
	//-----------------------------------------------------------

	void State_Eat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Eat ------");
		
		Eat_ResetAlertVars();
		mfEat_PrevPlayerDist = Eat_GetPlayerDistSqr();
		
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpPathfinder.Stop();
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		pCharBody.SetActiveSize(1);
		
		////////////////////
		// Turn to feed area!
		if (mvFindFood_FeedAreaPos.SqrLength() > 0.f)
		{
			mpMover.TurnToPos(mvFindFood_FeedAreaPos);
		}
		else
		{
			Eat_PlayEatAnim();
		}
		
		/////////////////////
		// Disable food physics
		if (RatHandler_GetRatFoodIsThrownMeat(m_idEat_FoodEntityId))
		{
			Entity_SetCollideCharacter(cLux_ID_Entity(m_idEat_FoodEntityId).GetName(), false);
		}
		/////////////////////
		// Reset hunger timer
		else
		{
			mfHungerTimer = 0;
		}
		
		////////////////////
		// Play eat sound
		mpStateMachine.AddTimer("PlayEatSound", cMath_RandRectf(1.f, 10.f));
		
		////////////////////
		// Retreat after a time
		mpStateMachine.AddTimer("MoveToHole", cMath_RandRectf(gfRat_EatTimeMin, gfRat_EatTimeMax));
		
		////////////////////
		// Manage activation/deactivation of the body
		mpStateMachine.AddTimer("UpdateBody", cMath_RandRectf(1.f, 2.f));

	}

	//------------------------------------------------------------

	void State_Eat_Leave()
	{
		mpMover.SetUseMoveStateAnimations(true);	
		
		float fFreeSlotDelay = gfRat_FreeSlotDelay_Default;
		int lNextState = mpStateMachine.GetNextState();
		if (lNextState == eRatState_GoToHole || lNextState == eRatState_Hunt)
			fFreeSlotDelay = gfRat_FreeSlotDelay_Brief;
		else if (lNextState == eRatState_Dead)
			fFreeSlotDelay = gfRat_FreeSlotDelay_Death;
		
		RatHandler_RemoveEatingRat(mBaseObj.GetID(), fFreeSlotDelay, m_idEat_FoodEntityId);
		RatHandler_RemoveAlertedRat(mBaseObj.GetID());
		
		mfHungerTimer = cMath_RandRectf(gfRat_HungerTimeMin, gfRat_HungerTimeMax);

		// Enable character body
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		pCharBody.SetActive(true);
		pCharBody.SetActiveSize(0);
		
		mpHeadTracker.SetActive(false);
	}
	
	//------------------------------------------------------------
	
	void State_Eat_Update(float afTimeStep)
	{
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		
		////////////////////
		// Alerted by player?
		float fDistToPlayerSqr =  Eat_GetPlayerDistSqr();
		float fDistY = cMath_Abs(vPlayerFeetPos.y - mBaseObj.GetCharBody().GetFeetPosition().y);
		bool bInAlertRange = fDistToPlayerSqr < gfRat_AlertDistMinSqr && fDistY < 1.5f && mBaseObj.GetPlayerIsInLineOfSight();
		
		if (bInAlertRange && 
			fDistToPlayerSqr < mfEat_PrevPlayerDist && 
			RatHandler_GetRatFoodIsThrownMeat(m_idEat_FoodEntityId)==false &&
			RatHandler_GetRatsAreAggressive())
		{
			mfEat_AlertCount = 0;
			if (!mbEat_IsAlerted)
				mbEat_IsAlerted = RatHandler_AddAlertedRat(mBaseObj.GetID());
		}
		
		if (mbEat_IsAlerted)
		{
			float fPrevCount = mfEat_AlertCount;
			float fTimerMul = bInAlertRange ? 1.0f : 3.0f;
			mfEat_AlertCount += afTimeStep*fTimerMul;
			
			if (!bInAlertRange)
			{
				Eat_ResetAlertVars();				
				Eat_PlayEatAnim();
				
				RatHandler_RemoveAlertedRat(mBaseObj.GetID());
			}
			
			else if (mfEat_AlertCount >= mfEat_TimeUntilAlert && fPrevCount < mfEat_TimeUntilAlert)
			{
				if (RatHandler_GetRatsAreAggressive())
				{
					Eat_PlayAlertAnim();
				}
				else
				{
					Eat_ResetAlertVars();				
					Eat_PlayEatAnim();
				
					RatHandler_RemoveAlertedRat(mBaseObj.GetID());
				}
			}
		}
		mfEat_PrevPlayerDist = fDistToPlayerSqr;
		
		//////////////////
		// Attacks
		bool bAttack = fDistToPlayerSqr < gfRat_ForceAttackDistSqr && fDistY < 1.5f && RatHandler_GetRatFoodIsThrownMeat(m_idEat_FoodEntityId)==false && mBaseObj.GetPlayerIsInLineOfSight();
		
		///////////////////////
		// Check if player is jumping (note that IsOnGround wouldn't work here since it takes a while after leaving ground for that to change to false)
		if (bAttack && GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness) < 1.0f && vPlayerFeetPos.y > (mBaseObj.GetCharBody().GetFeetPosition().y + 0.05))
			bAttack = false;
			
		if (bAttack && RatHandler_GetRatsAreAggressive() == false)
			bAttack = false;
			
		if (GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness) < 1.0f)
		{
			if (!bAttack)
				mfEat_AttackTimer = 1.0f;
			else
				mfEat_AttackTimer -= afTimeStep;
			
			if (mfEat_AttackTimer > 0)
				bAttack = false;
		}
			
		if (bAttack)
		{
			mbHunt_ProtectingFood = true;
			if (RatHandler_GetAttackAllowed())
			{
				RatHandler_DoRatAttack();
				
				mbAttack_Fast = true;
				mpStateMachine.ChangeState(eRatState_Hunt);
			}
			else
			{
				mpStateMachine.ChangeState(eRatState_Hunt);
			}
			return;
		}
	}
	
	//------------------------------------------------------------
	
	bool State_Eat_Message(int alMessageId)
	{
		////////////////////
		// Turned toward area?
		if (alMessageId == eLuxEntityMessage_TurningDone)
		{
			Eat_PlayEatAnim();
		}
		
		////////////////////
		// Restart eat anim!
		else if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimationState == "EatVariation")
			{
				Eat_PlayEatAnim();
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_Eat_TimerUp(uint64 alId)
	{
		if (H64("PlayEatVariationAnim") == alId)
		{
			msAnimationState = "EatVariation";
			
			int lAnimId = cMath_RandRectl(0, gvRatAnim_EatVariation.length() - 1);
			mpMover.PlayAnimation(gvRatAnim_EatVariation[lAnimId], 0.3f, false);
		}
		else if (H64("PlayEatSound") == alId)
		{
			mBaseObj.PlaySound("Sound_Eat", gsRatSound_Eat, true, true);
			mpStateMachine.AddTimer("PlayEatSound", cMath_RandRectf(3.f, 7.f));
		}
		else if (H64("MoveToHole") == alId)
		{
			if (mbEat_TimeoutActive==false || mbEat_IsAlerted)
				mpStateMachine.AddTimer("MoveToHole", 2.0f);
			else
				GoToHole(true, tID_Invalid);
		}
		else if (H64("ReactToGunShot") == alId)
		{
			Eat_TriggerAlert();
		}
		else if (H64("UpdateBody") == alId)
		{
			mpStateMachine.AddTimer("UpdateBody", 2.0f);
			if (!mbEat_IsAlerted)
			{
				bool bActivateBody = mBaseObj.GetDistanceToPlayer2D() < gfRat_EatBodyActivationDist;
				mBaseObj.GetCharBody().SetActive(bActivateBody);
			}
			else
			{
				mBaseObj.GetCharBody().SetActive(true);
			}
		}
		else if (H64("ReplayAlertSound") == alId)
		{
			if (mbEat_IsAlerted)
			{
				Eat_PlayAlertSound();
				mpStateMachine.AddTimer("ReplayAlertSound", cMath_RandRectf(2, 6));
			}
		}
	}
	
	//------------------------------------------------------------
	
	void Eat_PlayEatAnim()
	{
		mpMover.SetUseMoveStateAnimations(false);
		
		msAnimationState = "Eat";
		mpMover.PlayAnimation(gsRatAnim_Eat, 0.3f, true);
		mBaseObj.GetMeshEntity().GetAnimationStateFromName(gsRatAnim_Eat).SetRelativeTimePosition(cMath_RandRectf(0.0f, 1.0f));
		
		mpStateMachine.AddTimer("PlayEatVariationAnim", cMath_RandRectf(8.0f, 16.f));
		
		mpHeadTracker.SetActive(false);
	}
	
	//------------------------------------------------------------
	
	void Eat_TriggerAlert()
	{
		Eat_PlayAlertAnim();
		mfEat_AlertCount = 0;
		if (!mbEat_IsAlerted)
			mbEat_IsAlerted = RatHandler_AddAlertedRat(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------
	
	void Eat_PlayAlertAnim()
	{
		if (msAnimationState == "Alert")
			return;
		
		mpStateMachine.StopTimer("PlayEatVariationAnim");
		
		msAnimationState = "Alert";		
		mpMover.PlayAnimation(gsRatAnim_Alert, 0.3f, true);
		
		Eat_PlayAlertSound();
		mpStateMachine.AddTimer("ReplayAlertSound", cMath_RandRectf(3, 6));
		
		mpHeadTracker.SetActive(true);
	}
	
	//------------------------------------------------------------
	
	void Eat_PlayAlertSound()
	{
		mBaseObj.PlaySound("Sound_Alert", gsRatSound_Alert, true, true);
		if (GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness) >= 1.0f)
			mBaseObj.GetMap().BroadcastSoundHeardEvent("RatScream", mBaseObj.GetPosition(), 15, 4, false, false);
	}
	
	//------------------------------------------------------------
	
	void Eat_ResetAlertVars()
	{
		mbEat_IsAlerted = false;
		mfEat_AlertCount = 0.f;
		mfEat_TimeUntilAlert = cMath_RandRectf(gfRat_AlertTimeMin, gfRat_AlertTimeMax);
		mfEat_TimeUntilUnalert = cMath_RandRectf(gfRat_UnalertTimeMin, gfRat_UnalertTimeMax);
	}
	
	//------------------------------------------------------------
	
	float Eat_GetPlayerDistSqr()
	{
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		iLuxEntity@ pFood = cLux_ID_Entity(m_idEat_FoodEntityId);
		cVector3f vFoodPos = pFood is null ? mBaseObj.GetCharBody().GetPosition() : pFood.GetPosition();
		cVector3f vDelta = vPlayerFeetPos - vFoodPos;
		vDelta.y = 0.f;
		
		return vDelta.SqrLength();
	}
	
	//------------------------------------------------------------

	//} END STATE: EAT
	
	///////////////////////////////////
	// STATE: FIND FOOD
	//{////////////////////////////////
	
	//-----------------------------------------------------------
	
	int mlFindFood_PositionStage = 0;
	float mfFindFood_PositionCount = 0.f;
	cVector3f mvFindFood_FeedAreaPos = cVector3f(0.f);
	cVector3f mvFindFood_EatGoalPos = cVector3f(0.f);
	cVector3f mvFindFood_EatStartPos = cVector3f(0.f);
	tID m_idFindFood_FoodEntityId = tID_Invalid;
	bool mbFindFood_SensesActive = true;
	float mfFindFood_ClosestDistReached = 1000;
	float mfFindFood_TimeSinceClosestDist = 0;
	
	//-----------------------------------------------------------

	void State_FindFood_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: FindFood ------");
		
		mlFindFood_PositionStage = 0;
		mfFindFood_PositionCount = 0.f;
		mvFindFood_EatStartPos = cVector3f(0.f);
		mvFindFood_EatGoalPos = cVector3f(0.f);
		mfFindFood_ClosestDistReached = 1000;
		mfFindFood_TimeSinceClosestDist = 0;
		
		///////////////////////
		// Do we have a goal?
		if (m_idFindFood_FoodEntityId == tID_Invalid)
			m_idFindFood_FoodEntityId = RatHandler_GetFreeFoodEntityId(mBaseObj.GetID(), false, true);
		
		if (m_idFindFood_FoodEntityId != tID_Invalid && RatHandler_GetRatFoodIsThrownMeat(m_idFindFood_FoodEntityId)==false)
		{
			cVector3f vEatPos = RatHandler_AddEatingRat(mBaseObj.GetID(), m_idFindFood_FoodEntityId);
			if (vEatPos.SqrLength()==0)
			{
				GoToHole(false, m_idEmerge_Hole);
				return;
			}
		}
			
		//////////////////////////////
		// temp fix for bugged mesh bounds
		if (RatHandler_GetRatFoodIsArea(m_idFindFood_FoodEntityId)==false)
		{
			iLuxEntity@ pEntity = cLux_ID_Entity(m_idFindFood_FoodEntityId);
			if (pEntity is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No available feed entity! This shouldn't happen.");
				WanderThenHide(true);
				return;
			}
			
			mvFindFood_FeedAreaPos = pEntity.GetPosition();
		}
		else
		{
			cLuxArea@ pArea = cLux_ID_Area(m_idFindFood_FoodEntityId);
			if (pArea is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No available feed area! This shouldn't happen.");
				WanderThenHide(true);
				return;
			}
			
			mvFindFood_FeedAreaPos = pArea.GetPosition();
		}
		
		///////////////////////
		// Move to goal!
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpPathfinder.MoveTo(mvFindFood_FeedAreaPos, 1.f, false);
		mpStateMachine.AddTimer("UpdateFeedAreaPos", 1);
	}

	//------------------------------------------------------------

	void State_FindFood_Leave()
	{
		mbFindFood_SensesActive = true;
		if (mpStateMachine.GetNextState() != eRatState_Eat)
		{
			RatHandler_RemoveEatingRat(mBaseObj.GetID(), 0, m_idFindFood_FoodEntityId);
		}
	}
	
	//------------------------------------------------------------
	
	void State_FindFood_Update(float afTimeStep)
	{
		///////////////////
		// Setup vars
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		
		cVector3f vDelta = mvFindFood_FeedAreaPos - pCharBody.GetFeetPosition();
		float fDistSqr = vDelta.SqrLength();
		float fYDist = cMath_Abs(vDelta.y);
			
		//////////////////////////
		// Check if food is unreachable
		if (fDistSqr < 5.f * 5.f)
		{
			if (mfFindFood_ClosestDistReached > fDistSqr)
			{
				mfFindFood_ClosestDistReached = fDistSqr;
				mfFindFood_TimeSinceClosestDist = 0;
			}
			
			mfFindFood_TimeSinceClosestDist += afTimeStep;
			if (mfFindFood_TimeSinceClosestDist > 2.0f)
			{
                cLux_AddDebugMessage("FOOD UNREACHABLE");
				Retreat(eRatSpeed_Walk, false, false);
				RatHandler_ReportUnreachableFood(m_idFindFood_FoodEntityId);
			}
		}
		
		///////////////////
		// Move to feed area
		if (mlFindFood_PositionStage == 0)
		{			
			if (fDistSqr < 2.f * 2.f && fYDist < 0.5f)
			{
				///////////////////
				// Setup next stage
				mlFindFood_PositionStage = 1;
				mpMover.SetSpeedState(eRatSpeed_SlowWalk);
				
				///////////////////////////////////////////////
				// Add again in case it wasn't added on enter
				if (RatHandler_GetRatFoodIsThrownMeat(m_idFindFood_FoodEntityId))
				{
					mvFindFood_EatGoalPos = RatHandler_AddEatingRat(mBaseObj.GetID(), m_idFindFood_FoodEntityId);
					if (mvFindFood_EatGoalPos.SqrLength() == 0)
					{
						GoToHole(false, tID_Invalid);
						return;
					}
				}
				else
				{
					mvFindFood_EatGoalPos = RatHandler_GetFeedWorldPos(mBaseObj.GetID(), m_idFindFood_FoodEntityId);
				}
				
				mpStateMachine.StopTimer("UpdateFeedAreaPos");
			}
		}
		
		///////////////////
		// Move to feed pos
		else if (mlFindFood_PositionStage == 1)
		{
			///////////////////
			// Move
			pCharBody.Move(eCharDir_Forward, 1.f);
			mpMover.TurnToPos(mvFindFood_EatGoalPos);
			
			///////////////////
			// Setup next stage?
			float fDistSqr = (mvFindFood_EatGoalPos - pCharBody.GetFeetPosition()).SqrLength();
			
			if (fDistSqr < 0.5f * 0.5f)
			{		
				mlFindFood_PositionStage = 2;
				mvFindFood_EatStartPos = pCharBody.GetFeetPosition();
				
				mpMover.StopTurning();
				mBaseObj.GetCharBody().StopMovement();
			}
		}
		
		///////////////////
		// Fine positioning
		else if (mlFindFood_PositionStage == 2)
		{
			////////////////
			// Time
			float fPositionTime = 0.3f;
			
			mfFindFood_PositionCount += afTimeStep;
			if (mfFindFood_PositionCount > fPositionTime)
				mfFindFood_PositionCount = fPositionTime;
			
			float fT = mfFindFood_PositionCount / fPositionTime;
			
			////////////////
			// Position
			cVector3f vPos = mvFindFood_EatStartPos * (1.f - fT) + mvFindFood_EatGoalPos * fT;
			pCharBody.SetFeetPosition(vPos, true);
			
			////////////////
			// Done?
			if (fT >= 1.f)
			{
				RatHandler_ReportReachableFood(m_idFindFood_FoodEntityId);
				
				m_idEat_FoodEntityId = m_idFindFood_FoodEntityId;
				mpStateMachine.ChangeState(eRatState_Eat);
			}
		}
	}
	
	//------------------------------------------------------------
	
	bool State_FindFood_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_StuckCounterIsAtMax)
		{
			Retreat(eRatSpeed_Walk, false, false);
			RatHandler_ReportUnreachableFood(m_idFindFood_FoodEntityId);
			return true;
		}
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_FindFood_TimerUp(uint64 alId)
	{
		if (H64("UpdateFeedAreaPos") == alId)
		{
			mpStateMachine.AddTimer("UpdateFeedAreaPos", 1);
			
			cVector3f vNewPos = mvFindFood_FeedAreaPos;
			
			//////////////////////////////
			// temp fix for bugged mesh bounds
			if (RatHandler_GetRatFoodIsArea(m_idFindFood_FoodEntityId)==false)
			{
				iLuxEntity@ pEntity = cLux_ID_Entity(m_idFindFood_FoodEntityId);
				if (pEntity is null)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No available feed entity! This shouldn't happen.");
					return;
				}
				
				vNewPos = pEntity.GetPosition();
			}
			else
			{
				cLuxArea@ pArea = cLux_ID_Area(m_idFindFood_FoodEntityId);
				if (pArea is null)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No available feed area! This shouldn't happen.");
					return;
				}
				
				vNewPos = pArea.GetPosition();
			}
			
			if (cMath_Vector3DistSqr(mvFindFood_FeedAreaPos, vNewPos) < (0.25*0.25))
				return;
			
			mvFindFood_FeedAreaPos = vNewPos;
			mpPathfinder.MoveTo(mvFindFood_FeedAreaPos, 1.f, false);
		}
	}
	
	//------------------------------------------------------------
	
	void FindFood_Setup(tID a_idTargetFood, bool abSensesActive=true)
	{
		m_idFindFood_FoodEntityId = a_idTargetFood;
		mbFindFood_SensesActive = abSensesActive;
	}
	
	//------------------------------------------------------------

	//} END STATE: FIND FOOD

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: RETREAT
	//{////////////////////////////////
	//------------------------------------------------------------
	
	bool mbRetreat_Scared = false;
	bool mbRetreat_SensesActive = true;
	int mlRetreat_SpeedState = eRatSpeed_Walk;
	eRatRetreatReason mRetreat_Reason;
	tID m_idRetreat_TargetHole = tID_Invalid;
	
	//------------------------------------------------------------

	void State_Retreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Retreat ------",false,true);
		
		///////////////////
		// Move to hole!
		mpMover.SetSpeedState(mlRetreat_SpeedState);
		if (Retreat_MoveToHole()==false)
		{
			////////////////////
			// Try ignoring damage areas if no safe node was found
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No path found to hole, ignoring damage areas!", false, true);
			RatHandler_SetRatIgnoresDamageAreas(mBaseObj.GetID(), true);
			if (Retreat_MoveToHole()==false)
			{
				WanderThenHide(mbRetreat_SensesActive);
			}
		}
		
		///////////////////
		// Play scared sound?
		if (mbRetreat_Scared)
		{
			mpStateMachine.AddTimer("PlayScaredSound", cMath_RandRectf(0.1f, 0.3f));
		}
	}

	//------------------------------------------------------------

	void State_Retreat_Leave()
	{
		Blackboard_SetPlayerBlocksPath(mBaseObj, false);
		mbRetreat_Scared = false;
		mbRetreat_SensesActive = true;
		mlRetreat_SpeedState = eRatSpeed_Walk;
		mpMover.SetTurnSpeedMul(1);
		
		SetCollide(true);
	}

	//------------------------------------------------------------

	void State_Retreat_Update(float afTimeStep)
	{				
		UpdateMovingToHole(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_Retreat_Message(int alMessageId)
	{		
		if (MovingToHole_Message(alMessageId))
			return true;
			
		return false;
	}
	
	//------------------------------------------------------------

	void State_Retreat_TimerUp(uint64 alId)
	{
		if (H64("PlayScaredSound") == alId)
		{
			tString sSound = gsRatSound_Fear;
			if (mRetreat_Reason == eRatRetreatReason_Flame)
				sSound = gsRatSound_FearFlame;
				
			mBaseObj.PlaySound("Sound_Fear", sSound, true, true);
			mpStateMachine.AddTimer("PlayScaredRunSound", cMath_RandRectf(0.5f, 1.0f));
		}
		if (H64("PlayScaredRunSound") == alId)
		{
			mBaseObj.PlaySound("Sound_FearRun", gsRatSound_FearRun, true, true);
			mpStateMachine.AddTimer("PlayScaredRunSound", cMath_RandRectf(0.5f, 1.0f));
		}
	}
	
	//------------------------------------------------------------
	
	bool Retreat_MoveToHole()
	{
		//////////////////
		// Get hole
		m_idTargetHole = m_idRetreat_TargetHole == tID_Invalid ? RatHandler_GetBestHoleIdFromPos(mBaseObj.GetPosition()) : m_idRetreat_TargetHole;
		m_idRetreat_TargetHole = tID_Invalid;
		
		if (m_idTargetHole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No hole with available path to retreat to!",false,true);
			return false;
		}
		
		//////////////////
		// Move to hole
		msMovingToHoleState = "GoToHole";	
	
		mvTargetHoleFeetPos = GetHoleGroundPos(m_idTargetHole);
		mvTargetHolePos = GetInnerHolePos(m_idTargetHole);		
		
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvTargetHoleFeetPos, 0.f, 3.f, true, false, false, null);
		if (pNode !is null)
		{
			MoveToPos_ForceUpdate(pNode.GetPosition(), 2.f, false);
			return true;
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No node by retreat hole!",false,true);
			return false;
		}
	}
	
	//------------------------------------------------------------

	//} END RETREAT

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: GO TO HOLE
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_GoToHole_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Go To Hole ------",false,true);
		
		if (m_idTargetHole == tID_Invalid)
		{
			bool bSenses = true;
			if (mpStateMachine.GetPrevState()==eRatState_WanderThenHide)
				bSenses = mbWanderThenHide_SensesActive;
			WanderThenHide(bSenses);
			return;
		}
		
		///////////////////
		// Move to hole!
		mpMover.SetSpeedState(eRatSpeed_Walk);
		
		msMovingToHoleState = "GoToHole";	
	
		mvTargetHoleFeetPos = GetHoleGroundPos(m_idTargetHole);
		mvTargetHolePos = GetInnerHolePos(m_idTargetHole);		
		
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvTargetHoleFeetPos, 0.f, 3.f, true, false, false, null);
		if (pNode !is null)
		{
			mpPathfinder.MoveTo(pNode.GetPosition(), 1.f, false);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No node by hole!",false,true);
			return;
		}
	}

	//------------------------------------------------------------

	void State_GoToHole_Leave()
	{
		Blackboard_SetPlayerBlocksPath(mBaseObj, false);
		SetCollide(true);
	}

	//------------------------------------------------------------

	void State_GoToHole_Update(float afTimeStep)
	{	
		UpdateMovingToHole(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_GoToHole_Message(int alMessageId)
	{		
		if (MovingToHole_Message(alMessageId))
			return true;
			
		return false;
	}
	
	//------------------------------------------------------------
	
	void GoToHole_SelectHole(bool abUseBestHole, tID a_idIgnoredHole)
	{
		if (abUseBestHole)
		{
			m_idTargetHole = RatHandler_GetBestHoleIdFromPos(mBaseObj.GetPosition());
		}
		else
		{
			m_idTargetHole = RatHandler_GetRandomHoleId(a_idIgnoredHole, true, mBaseObj.GetPosition());
		}
	}
	
	//------------------------------------------------------------

	//} END GO TO HOLE
	
	///////////////////////////////////
	// STATE: EMERGE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvEmerge_GoalPos = cVector3f(0.f);
	tID m_idEmerge_Hole = tID_Invalid;
	tID m_idEmerge_Target = tID_Invalid;
	eRatEmergeType mEmerge_Type = eRatEmergeType_LastEnum;
	bool mbEmerge_FoundFood = false;
	
	//------------------------------------------------------------

	void State_Emerge_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Emerge ------",false,true);
		
		SetCollide(false);
		
		////////////////////
		// Allow tracking blood trails
		mbAllowTrackBloodTrail = true;
				
		////////////////////
		// Setup emerge goal
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mvEmerge_GoalPos = GetHoleGroundPos(m_idEmerge_Hole);
		
		////////////////////
		// Reset hunger
		mfHungerTimer = 0;
		
		////////////////////
		// Stop hiding!
		RatHandler_RemoveHidingRat(mBaseObj.GetID());
	}

	//------------------------------------------------------------

	void State_Emerge_Leave()
	{
		//m_idEmerge_Hole = tID_Invalid;
		SetCollide(true);
	}

	//------------------------------------------------------------

	void State_Emerge_Update(float afTimeStep)
	{
		////////////////////
		// Exit hole!
		mpMover.TurnToPos(mvEmerge_GoalPos);
		mBaseObj.GetCharBody().Move(eCharDir_Forward, 1.f);
			
		if (GetDistanceToPosSqr2D(mvEmerge_GoalPos) < 0.2f * 0.2f)
		{
			if (mEmerge_Type == eRatEmergeType_Food)
			{
				FindFood_Setup(m_idEmerge_Target);
				mpStateMachine.ChangeState(eRatState_FindFood);
			}
			else if (mEmerge_Type == eRatEmergeType_Wander)
			{
				GoToHole(m_idEmerge_Target);
			}
			else if (mEmerge_Type == eRatEmergeType_BloodTrail)
			{
				m_idTrackBloodTrail_CurrentTrailId = m_idEmerge_Target;
				mpStateMachine.ChangeState(eRatState_TrackBloodTrail);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_Emerge_Message(int alMessageId)
	{		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Emerge_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------
	
	bool Emerge_Setup(tID a_idEmergeHole, tID a_idTarget, eRatEmergeType aType)
	{
		m_idEmerge_Hole = a_idEmergeHole;
		m_idEmerge_Target = a_idTarget;
		mEmerge_Type = aType;
		
		////////////////////
		// Position at hole
		if (m_idEmerge_Hole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Emerge hole was invalid, this shouldn't happen!");
			return false;
		}
		
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		float fEmergeAngle = GetHoleAngle(m_idEmerge_Hole);
		cVector3f vEmergeStartPos = GetInnerHolePos(m_idEmerge_Hole);
		
		pCharBody.SetYaw(fEmergeAngle);
		pCharBody.SetFeetPosition(vEmergeStartPos, false);
		
		return true;
	}
	
	//------------------------------------------------------------

	//} END EMERGE
	
	///////////////////////////////////
	// STATE: HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfHunt_MaxDistUntilRetreat = gfRat_AttackMaxDistUntilRetreat;
	float mfHunt_MaxTimeUntilRetreat = gfRat_AttackMaxTimeUntilRetreat;
	cVector3f mvHunt_StartPos = cVector3f(0.f);
	bool mbHunt_ProtectingFood = false;
	float mfHunt_PrevPlayerDistFromFood = 1000.0f;
	float mfHunt_PlayerRetreatCount = 0;
	float mfHunt_PlayerRetreatMaxTime = gfRat_AttackMaxPlayerRetreatTime;
	
	//------------------------------------------------------------

	void State_Hunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Hunt ------",false,true);
		
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			//Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		int lPrevState = mpStateMachine.GetPrevState();
		
		if (mbHunt_ProtectingFood)
		{
			iLuxEntity@ pFood = cLux_ID_Entity(m_idEat_FoodEntityId);
			if (pFood !is null)
				mvHunt_StartPos = pFood.GetPosition();
				
			mfHunt_MaxDistUntilRetreat = cMath_RandRectf(gfRat_AttackMinDistUntilRetreat_FromEating, gfRat_AttackMaxDistUntilRetreat_FromEating);
			mfHunt_PlayerRetreatMaxTime = cMath_RandRectf(gfRat_AttackMinPlayerRetreatTime, gfRat_AttackMaxPlayerRetreatTime);
		}
		else
		{
			mvHunt_StartPos = mBaseObj.GetCharBody().GetFeetPosition();
			
			mfHunt_MaxDistUntilRetreat = cLux_GetPlayer().GetHealth() == 1.0f ? 
											cMath_RandRectf(gfRat_AttackMinDistUntilRetreat_NoDamage, gfRat_AttackMaxDistUntilRetreat_NoDamage) :
											cMath_RandRectf(gfRat_AttackMinDistUntilRetreat, gfRat_AttackMaxDistUntilRetreat);
		}
										
		mfHunt_MaxTimeUntilRetreat = cMath_RandRectf(gfRat_AttackMinTimeUntilRetreat, gfRat_AttackMaxTimeUntilRetreat);
		
		mpMover.SetIdleAnimName(gsRatAnim_Attack_Idle);
		
		/////////////////////
		// Start pursuit
		mpMover.SetSpeedState(eRatSpeed_Run);
		mpStateMachine.AddTimer("Pursuit", cMath_RandRectf(0.5f, 1.f));
		
		/////////////////////
		// Register as attacking
		RatHandler_AddAttackingRat(mBaseObj.GetID());
	}

	//------------------------------------------------------------

	void State_Hunt_Leave()
	{		
		if (mpStateMachine.GetNextState() != eRatState_Attack && mpStateMachine.GetNextState() != eRatState_PostAttack)
		{
			RatHandler_RemoveAttackingRat(mBaseObj.GetID());
			mpMover.SetIdleAnimName(GetRandomAnim(gvRatAnim_Normal_Idle));
			mbHunt_ProtectingFood = false;
			
			mfHunt_PrevPlayerDistFromFood = 1000.0f;
			mfHunt_PlayerRetreatCount = 0;
		}
	}

	//------------------------------------------------------------

	void State_Hunt_Update(float afTimeStep)
	{
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		mfHunt_MaxTimeUntilRetreat -= afTimeStep;
		if (mfHunt_MaxTimeUntilRetreat <= 0)
		{
			if (mbHunt_ProtectingFood)
			{
				FindFood_Setup(m_idEat_FoodEntityId, false);
				mpStateMachine.ChangeState(eRatState_FindFood);
			}
			else
			{
				Retreat(eRatSpeed_Run, false, false);
			}
			return;
		}
		
		/////////////////
		// Attack player?
		cLuxPlayer@ pPlayer = cLux_GetPlayer();
		if (pPlayer.IsDead()) return;
		
		///////////////
		// Check if player is backing off
        
		if (mbHunt_ProtectingFood && mfHunt_PlayerRetreatCount > mfHunt_PlayerRetreatMaxTime)
		{	
			Hunt_GiveUp();
			return;
		}
		
		float fDistSqr = GetDistanceToPosSqr2D(mBaseObj.GetPlayerFeetPos());
				
		if (fDistSqr < gfRat_AttackDistanceSqr && 
			mBaseObj.GetPlayerIsInLineOfSight())
		{
			bool bDoAttack = true;
			if (RatHandler_GetAttackAllowed() == false)
			{
				bDoAttack = false;
			}
            
			else if (mbHunt_ProtectingFood)
			{
				cVector3f vPlayerPos = Player_GetFeetPosition();
				float fPathDist = GetPathDistanceToPos(mvHunt_StartPos, mBaseObj.GetCharBody().GetFeetPosition());
				
				bool bDistanceOK = cMath_Vector3DistSqr(mvHunt_StartPos, vPlayerPos) < gfRat_ForceAttackDistSqr;
				bool bRetreatOK = mfHunt_PlayerRetreatCount < mfHunt_PlayerRetreatMaxTime && fPathDist < mfHunt_MaxDistUntilRetreat;
				if (!bRetreatOK && !bDistanceOK)
					bDoAttack = false;
			}
			
			if (bDoAttack)
			{
				RatHandler_DoRatAttack();
				
				mbAttack_Fast = false;
				mpStateMachine.ChangeState(eRatState_Attack);
			}
			else
			{
				mpPathfinder.Stop();
				if (Map_TimeHasPassed("Rat_AttackWarnSound", cMath_RandRectf(0.5, 1.5)))
					mBaseObj.PlaySound("Sound_AttackWarn", gsRatSound_AttackWarning, true, true);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_Hunt_Message(int alMessageId)
	{		
		return false;
	}
	
	//------------------------------------------------------------

	void State_Hunt_TimerUp(uint64 alId)
	{
		if (H64("Pursuit") == alId)
		{
			/////////////////////////
			// Get distance to where attack started
			cVector3f vFeetPos = mBaseObj.GetCharBody().GetFeetPosition();
			float fDist = GetPathDistanceToPos(mvHunt_StartPos, vFeetPos);			
			
			if (fDist < 0.f)
			{
				fDist = (vFeetPos - mvHunt_StartPos).Length() * 1.25f;
			}
			
			/////////////////////////
			// Chased player far enough?
			if (fDist > mfHunt_MaxDistUntilRetreat)
			{
				Hunt_GiveUp();
				return;
			}
			
			/////////////////////////
			// Keep chasing!
			else
			{
				mpPathfinder.MoveTo(mBaseObj.GetPlayerFeetPos(), 1.f, false);
				mpStateMachine.AddTimer("Pursuit", cMath_RandRectf(0.1f, 0.3f));
			}
		}
	}
	
	//------------------------------------------------------------
	
	void Hunt_GiveUp()
	{
		if (mbHunt_ProtectingFood)
			FindFood_Setup(m_idEat_FoodEntityId, false);
			
		mpStateMachine.ChangeState(eRatState_FindFood);
	}
	
	//------------------------------------------------------------

	//} END HUNT
	
	///////////////////////////////////
	// STATE: ATTACK
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	tString msAttack_CurrentAnim;
	bool mbAttack_Fast = false;
	bool mbAttack_Warning = false;
	
	//------------------------------------------------------------

	void State_Attack_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Attack ------",false,true);
		
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		/////////////////////
		// Start pursuit
		mpMover.SetSpeedState(eRatSpeed_Attack);
		mpPathfinder.Stop();
			
		msAnimationState = "Attack";
		if (mbAttack_Fast)
			msAttack_CurrentAnim = gvRatAnim_AttackFast[cMath_RandRectl(0, gvRatAnim_AttackFast.length()-1)];
		else
			msAttack_CurrentAnim = gvRatAnim_Attack[cMath_RandRectl(0, gvRatAnim_Attack.length()-1)];
		mpMover.PlayAnimation(msAttack_CurrentAnim, 0.3f, false);
			
		mfHunt_MaxTimeUntilRetreat = cMath_RandRectf(gfRat_AttackMinDistUntilRetreat, gfRat_AttackMaxDistUntilRetreat);
	}

	//------------------------------------------------------------

	void State_Attack_Leave()
	{		
		mpMover.SetSpeedState(eRatSpeed_Run);
		
		if (mpStateMachine.GetNextState() != eRatState_PostAttack)
		{
			mbAttack_Warning = false;
			mbHunt_ProtectingFood = false;
			mfHunt_PrevPlayerDistFromFood = 1000.0f;
			mfHunt_PlayerRetreatCount = 0;
			
			RatHandler_RemoveAttackingRat(mBaseObj.GetID());
		}
	}

	//------------------------------------------------------------

	void State_Attack_Update(float afTimeStep)
	{
		/////////////////
		// Bite player?
		if (cLux_GetPlayer().IsDead()) 
		{
			Retreat(eRatSpeed_Walk, false, true);
			return;
		}
		
		float fDistSqr = GetDistanceToPosSqr2D(mBaseObj.GetPlayerFeetPos());
		if (fDistSqr > gfRat_BiteMinDistanceSqr)
		{
			mpMover.MoveToPos(mBaseObj.GetPlayerFeetPos());
		}
		else
		{
			mBaseObj.GetCharBody().StopMovement();
		}
	}
	
	//------------------------------------------------------------

	bool State_Attack_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			/////////////////
			// Give damage
			float fDamage = Player_GetHealth() < 1.0f ? gfRat_BiteDamage : gfRat_BiteDamage_FullHealth;
			fDamage *= GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsDamage);
			float fMinHealth = 0.05f;
			int lAttackId = mBaseObj.GetMap().GetNewAttackInstanceID();
			
			cScript_RunGlobalFunc("LuxPlayer", "", "_Global_GetCanDieFromNextRatBite");
			if (cScript_GetGlobalReturnBool())
			{
				fMinHealth = 0.f;
			}
			
			cLux_GetPlayer().GiveDamage(fDamage, 1.f, eDamageType_RatBite, fMinHealth, mBaseObj.GetID(), lAttackId);
			
			/////////////////
			// Play sound
			mBaseObj.PlaySound("Sound_BitePlayer", gsRatSound_Attack, true, true);
			
			mpStateMachine.ChangeState(eRatState_PostAttack);
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_Attack_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------

	//} END ATTACK
	
	///////////////////////////////////
	// STATE: POST ATTACK
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfPostAttack_MaxDistToPlayerMul = 1.f;
	
	//------------------------------------------------------------

	void State_PostAttack_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostAttack ------",false,true);
		
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		/////////////////
		// Setup behaviour
		mfPostAttack_MaxDistToPlayerMul = cMath_RandRectf(1.1f, 1.4f);
		
		mpMover.SetIdleExtraAnimActive(false);
		mpMover.SetIdleAnimName(gsRatAnim_Attack_Idle);
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpPathfinder.Stop();
	}

	//------------------------------------------------------------

	void State_PostAttack_Leave()
	{
		mpMover.SetIdleExtraAnimActive(true);
		
		DestroyBackstepCollideShape();
		
		mbAttack_Warning = false;
		
		if (mpStateMachine.GetNextState() != eRatState_Hunt)
		{
			mbHunt_ProtectingFood = false;
			mfHunt_PrevPlayerDistFromFood = 1000.0f;
			mfHunt_PlayerRetreatCount = 0;
			
			RatHandler_RemoveAttackingRat(mBaseObj.GetID());
			mpMover.SetIdleAnimName(GetRandomAnim(gvRatAnim_Normal_Idle));
		}
	}

	//------------------------------------------------------------

	void State_PostAttack_Update(float afTimeStep)
	{
		////////////////////
		// Setup vars
		iPhysicsWorld@ pPhysicsWorld = mBaseObj.GetMap().GetPhysicsWorld();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();
		iPhysicsBody@ pSkipBody = pCharBody.GetCurrentBody();
		
		cVector3f vPlayerPos = mBaseObj.GetPlayerFeetPos();
		
		cAnimationState@ pAnimState = msAttack_CurrentAnim != "" ? mBaseObj.GetMeshEntity().GetAnimationStateFromName(msAttack_CurrentAnim) : null;
		bool bAnimationOver = pAnimState is null ? true : pAnimState.IsOver();
		
		/////////////////
		// Run off?
		if (bAnimationOver)
		{
			PostAttack_EvaluateAction();
			return;
		}
		
		/////////////////////
		// Move toward player
		float fDistSqr = GetDistanceToPosSqr(vPlayerPos);
		if (bAnimationOver && fDistSqr > gfRat_PostAttackMaxDistToPlayerSqr * mfPostAttack_MaxDistToPlayerMul)
		{
			if (mpPathfinder.IsMoving() == false)
				mpPathfinder.MoveTo(vPlayerPos, 1.f, false);
			
			return;
		}		
		
		/////////////////////
		// Turn toward player
		else
		{
			mpPathfinder.Stop();
			mpMover.TurnToPos(vPlayerPos);
		}
		
		/////////////////////
		// Escape if far enough away!
		if (fDistSqr > gfRat_PostAttackMaxDistToPlayerSqr)
			return;
		
		if (bAnimationOver)
		{
			Backstep();
		}
	}
	
	//------------------------------------------------------------

	bool State_PostAttack_Message(int alMessageId)
	{		
		return false;
	}
	
	//------------------------------------------------------------

	void State_PostAttack_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------
	
	void PostAttack_EvaluateAction()
	{
		if (mbAttack_Warning)
		{
			FindFood_Setup(m_idEat_FoodEntityId, false);
			mpStateMachine.ChangeState(eRatState_FindFood);
			return;
		}
		
		if (mbHunt_ProtectingFood)
		{
			if (GetPathDistanceToPos(mvHunt_StartPos, mBaseObj.GetCharBody().GetFeetPosition()) > mfHunt_MaxDistUntilRetreat)
			{
				FindFood_Setup(m_idEat_FoodEntityId, false);
				mpStateMachine.ChangeState(eRatState_FindFood);
			}
			else
			{
				mpStateMachine.ChangeState(eRatState_Hunt);
			}
			return;
		}
		
		if (RatHandler_GetAttackingRatCount() < glRat_SkipRetreatMinAttackingRatNum)
		{
			if (mbHunt_ProtectingFood)
			{
				FindFood_Setup(m_idEat_FoodEntityId, false);
				mpStateMachine.ChangeState(eRatState_FindFood);
			}
			else
			{
				Retreat(eRatSpeed_Run, false, false);
			}
			return;
		}
		
		mpStateMachine.ChangeState(eRatState_Hunt);
	}
	
	//------------------------------------------------------------

	//} POST ATTACK
	
	///////////////////////////////////
	// STATE: TRACK BLOOD TRAIL
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	tID m_idTrackBloodTrail_CurrentTrailId = tID_Invalid;
	cVector3f mvTrackBloodTrail_GoalPos = cVector3f(0.f);
	float mfTrackBloodTrail_OutOfViewTimer = 2.0f;
	
	//------------------------------------------------------------

	void State_TrackBloodTrail_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: TrackBloodTrail ------",false,true);
		
		///////////////////
		// Tracking allowed?
		if (GetAllowTrackBloodTrail() == false)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blood tracking not allowed, returning to prev state!");
			TrackBloodTrail_ReturnToPrevState();
			return;
		}
		
		///////////////////
		// Get blood trail pos
		cLuxProp@ pTrail = cLux_ID_Prop(m_idTrackBloodTrail_CurrentTrailId);
		if (pTrail is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No blood trail found! Returning to prev state!");
			TrackBloodTrail_ReturnToPrevState();
			return;
		}
		
		mvTrackBloodTrail_GoalPos = pTrail.GetPosition();
		
		///////////////////
		// React to blood!
		mpPathfinder.Stop();
		
		msAnimationState = "Alert";
		
		mBaseObj.PlaySound("Sound_BloodReact", gsRatSound_BloodReact, true, true);
		mpMover.PlayAnimation(GetRandomAnim(gvRatAnim_Sniff), 0.3f, false);
		
		////////////////////
		// Change anims
		mpMover.SetIdleAnimName(gsRatAnim_Sniff_Idle);
		mpMover.SetWalkAnimName(gsRatAnim_Sniff_Walk);
		mpMover.SetWalkTurnAnimNames(gsRatAnim_Sniff_Walk_TurnLeft, gsRatAnim_Sniff_Walk_TurnRight);
		
		mBaseObj.SetCheckForDoors(true);
	}

	//------------------------------------------------------------

	void State_TrackBloodTrail_Leave()
	{
		mpMover.SetUseMoveStateAnimations(true);
		mpMover.SetSpeedMul(1.0f);
		
		////////////////////
		// Change anims
		mpMover.SetIdleAnimName(GetRandomAnim(gvRatAnim_Normal_Idle));
		mpMover.SetWalkAnimName(gsRatAnim_Normal_Walk);
		mpMover.SetWalkTurnAnimNames(gsRatAnim_Walk_TurnLeft, gsRatAnim_Walk_TurnRight);
		
		m_idTrackBloodTrail_CurrentTrailId = tID_Invalid;
		mvTrackBloodTrail_GoalPos = cVector3f(0.f);
		
		//////////////////
		// Disallow tracking (until enabled again)
		mbAllowTrackBloodTrail = false;
		
		mBaseObj.SetCheckForDoors(false);
	}

	//------------------------------------------------------------

	void State_TrackBloodTrail_Update(float afTimeStep)
	{
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		//////////////////////
		// Playing an anim?
		if (msAnimationState != "")
			return;
		
		//////////////////////
		// No goal?
		if (mvTrackBloodTrail_GoalPos.SqrLength() == 0.f)
		{
			TrackBloodTrail_ReturnToPrevState();
			return;
		}
		
		//////////////////////////
		// Hide rat if out of view to prevent the impression of wandering rats
		if (Entity_IsInPlayerFOV(mBaseObj.GetName()) == false) mfTrackBloodTrail_OutOfViewTimer -= afTimeStep;
		else mfTrackBloodTrail_OutOfViewTimer = 2.0f;
		
		if (Player_GetIsBleeding() == false && mfTrackBloodTrail_OutOfViewTimer <= 0.0f)
		{
			mBaseObj.SetActive(false);
			RatHandler_AddHidingRat(mBaseObj.GetID());
			return;
		}
		
		//////////////////////
		// At goal?
		float fDistToGoalSqr = GetDistanceToPosSqr2D(mvTrackBloodTrail_GoalPos);		
		if (fDistToGoalSqr < gfRat_ReachedBloodTrailDistSqr)
		{
			
			//////////////////////
			// Get next trail!			
			tID idTrail = RatHandler_GetMostRecentBloodTrailIdAtPos(mBaseObj.GetPosition(), gfRat_BloodTrailConnectionMaxDist);
			cLuxProp@ pTrail = cLux_ID_Prop(idTrail);
			
			//////////////////////
			// No new trail/doesn't exist?
			if (m_idTrackBloodTrail_CurrentTrailId == idTrail || pTrail is null)
			{
				TrackBloodTrail_ReturnToPrevState(true);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reached end of blood trail, smelling!");
				return;
			}
			
			//////////////////////
			// Update current trail
			m_idTrackBloodTrail_CurrentTrailId = idTrail;
			mvTrackBloodTrail_GoalPos = pTrail.GetPosition();
			
			//////////////////////
			// Retreat if path inside blocker!
			tID idBody;
			if (RatHandler_GetPointIsInsidePathBlocker(mvTrackBloodTrail_GoalPos, idBody))
			{
				iPhysicsBody@ pBody = cLux_ID_Body(idBody);
				bool bIsDamageArea = pBody !is null && Blackboard_GetIsBodyDamageArea(pBody);
                
				Retreat(bIsDamageArea ? eRatSpeed_Run : eRatSpeed_Walk, false, true);
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blood trail is inside path blocker, retreating!");
				return;
			}
			
			float fTrailIntensity = RatHandler_GetBloodTrailIntensity(m_idTrackBloodTrail_CurrentTrailId);
			float fBaseSpeed = 0.2f;
			float fSpeedMul = fBaseSpeed + (1.0f-fBaseSpeed)*fTrailIntensity;
			mpMover.SetSpeedMul(fSpeedMul);
			
			//////////////////////
			// Move to trail pos
			mpPathfinder.MoveTo(mvTrackBloodTrail_GoalPos, 1.f, false);
		}
	}
	
	//------------------------------------------------------------

	bool State_TrackBloodTrail_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimationState == "Alert")
			{
				msAnimationState = "";
				
				mpMover.SetUseMoveStateAnimations(true);
				mpMover.SetSpeedState(eRatSpeed_Walk);
			
				mpPathfinder.MoveTo(mvTrackBloodTrail_GoalPos, 1.f, false);
				
				float fRatAggressiveness = GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness);
		
				mpStateMachine.AddTimer("ReturnToPrevState", gfRat_BloodTrailMaxFollowTime * fRatAggressiveness);
			}
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_TrackBloodTrail_TimerUp(uint64 alId)
	{
		if (H64("ReturnToPrevState") == alId)
		{
			TrackBloodTrail_ReturnToPrevState(true);
		}
	}
	
	//------------------------------------------------------------
	
	void TrackBloodTrail_ReturnToPrevState(bool abSmellFirst = false)
	{
		int lPrevState = mpStateMachine.GetPrevState();
		
		if (abSmellFirst)
		{
			mbSmell_SmellingPlayer = false;
			mvSmell_SmellPos = mvTrackBloodTrail_GoalPos;
			if (lPrevState == eRatState_Emerge)
			{
				GoToHole_SelectHole(false, tID_Invalid);
				mlSmell_NextState = eRatState_GoToHole;
			}
			else
			{
				mlSmell_NextState = lPrevState;
			}
			
			
			mpStateMachine.ChangeState(eRatState_Smell);
			return;
		}
		
		if (lPrevState == eRatState_Retreat)
		{
			Retreat(eRatSpeed(mpMover.GetSpeedState()), false, false);
		}
		else if (lPrevState == eRatState_GoToHole || lPrevState == eRatState_Emerge)
		{
			GoToHole(false, tID_Invalid);
		}
		else
		{
			mpStateMachine.ChangeState(lPrevState);
		}
	}
	
	//------------------------------------------------------------

	//} END TRACK BLOOD TRAIL
	
	///////////////////////////////////
	// STATE: SMELL
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbSmell_SmellingPlayer = false;
	int mlSmell_NextState = eRatState_Retreat;
	cVector3f mvSmell_SmellPos = cVector3f(0.f);
	
	//------------------------------------------------------------

	void State_Smell_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Smell ------",false,true);
		
		////////////////////
		// Setup pos
		if (mbSmell_SmellingPlayer)
			mvSmell_SmellPos = mBaseObj.GetPlayerFeetPos();
		
		////////////////////
		// Stop and turn toward pos
		mpPathfinder.Stop();
		
		if (mvSmell_SmellPos.SqrLength() > 0.f)
			mpMover.TurnToPos(mvSmell_SmellPos);	
			
		////////////////////
		// Change anims
		mpMover.SetIdleAnimName(gsRatAnim_Sniff_Idle);
		mpMover.PlayAnimation(GetRandomAnim(gvRatAnim_Sniff), 0.3f, false);
		
		////////////////////
		// React to smell!
		mBaseObj.PlaySound("Sound_Sniff", gsRatSound_Sniff, true, true);
		
		////////////////////
		// Attack player?
		if (mbSmell_SmellingPlayer)
		{
			mpStateMachine.AddTimer("Stalk", cMath_RandRectf(1.f, 2.f));
		}
		
		////////////////////
		// Enter next state
		else
		{
			mpStateMachine.AddTimer("EnterNextState", cMath_RandRectf(1.f, 2.f));
		}
	}

	//------------------------------------------------------------

	void State_Smell_Leave()
	{
		mbSmell_SmellingPlayer = false;
		mlSmell_NextState = eRatState_Retreat;
		mvSmell_SmellPos = cVector3f(0.f);
		
		mpMover.SetUseMoveStateAnimations(true);	
			
		////////////////////
		// Change anims
		mpMover.SetIdleAnimName(GetRandomAnim(gvRatAnim_Normal_Idle));
	}

	//------------------------------------------------------------

	void State_Smell_Update(float afTimeStep)
	{
		////////////////
		// Force attack?
		if (mbSmell_SmellingPlayer)
		{
			if (RatHandler_GetRatsAreAggressive() == false)
			{
				Retreat(eRatSpeed_Run, false, true);
				return;
			}
			
			cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
			float fDistY = cMath_Abs(vPlayerFeetPos.y - mBaseObj.GetCharBody().GetFeetPosition().y);
			float fDistSqr = GetDistanceToPosSqr2D(vPlayerFeetPos);
			
			if (fDistSqr < gfRat_SmellForceAttackPlayerMinDistSqr && fDistY < 1.5f)
			{
				mpStateMachine.ChangeState(eRatState_StalkPlayer);
			}
		}		
	}
	
	//------------------------------------------------------------

	bool State_Smell_Message(int alMessageId)
	{		
		return false;
	}
	
	//------------------------------------------------------------

	void State_Smell_TimerUp(uint64 alId)
	{
		if (H64("Stalk") == alId)
		{
			mpStateMachine.ChangeState(eRatState_StalkPlayer);
		}
		else if (H64("EnterNextState") == alId)
		{
			if (mlSmell_NextState == eRatState_Retreat)
			{
				Retreat(eRatSpeed_Walk, false, false);
			}
			else
			{
				mpStateMachine.ChangeState(mlSmell_NextState);
			}
		}
	}
	
	//------------------------------------------------------------

	//} END SMELL
	
	///////////////////////////////////
	// STATE: DEAD
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlDead_HitboxBodyId = -1;
	float mfDead_HitForce = 0.f;
	float mfDead_HitMaxImpulse = 0.f;
	cVector3f mvDead_HitPosition = cVector3f(0.f);
	cVector3f mvDead_HitOrigin = cVector3f(0.f);
	tString msDead_Anim = "";
	bool mbDead_AnimIsPose = false;
	
	//------------------------------------------------------------

	void State_Dead_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Dead ------",false,true);
		
		GameStats_IncreaseEntryAmount(eHeroStats_RatsKilled);

		//////////////////
		// Setup dead
		mpMover.StopTurning();
		mpPathfinder.Stop();
		mpMover.SetUseMoveStateAnimations(false);
		
		if (msDead_Anim == "")
		{
			SetRagdollActive(true, 0);
			Dead_ActivateDeathState();
		}
		else if (!mbDead_AnimIsPose)
		{
			mBaseObj.PlayAnimation(msDead_Anim, 0.3, false);
			float fAnimationLength = mBaseObj.GetMeshEntity().GetAnimationStateFromName(msDead_Anim).GetLength();
			mpStateMachine.AddTimer("ActivateRagdoll", cMath_Max(fAnimationLength-0.5f, 0.0f));
		}
		else
		{
			float fFadeTime = 0.4f;
			mBaseObj.PlayAnimation(msDead_Anim, fFadeTime, true);
			mBaseObj.GetMeshEntity().GetAnimationStateFromName(msDead_Anim).SetPaused(true);
			mBaseObj.GetMeshEntity().GetAnimationStateFromName(msDead_Anim).SetRelativeTimePosition(1.0f);
			mpStateMachine.AddTimer("ActivateDeathState", fFadeTime);
			
			SetRagdollActive(true, fFadeTime);
		}
		
		///////////////////////////
		// ValG Edit, key drop
		
		//////////////////
		// Spawn pickup key
		
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap !is null)
		{
			pMap.CreateEntity("ChurchKey", glRat_KeyPickupEntity, cMatrixf_Identity, mBaseObj.GetOnLoadScale());
			cLuxProp@ pKeyPickup = cLux_ToProp(pMap.GetLatestEntity());
			
			if (pKeyPickup !is null)
			{
				pKeyPickup.SetMatrix(mBaseObj.GetMatrix());
				//pKeyPickup.GetMainBody().SetCollideFlags(mBaseObj.GetMap().GetCollideFlag("+key"));
				pKeyPickup.GetMainBody().SetCollideCharacter(false);
				//if (mbDead_Ragdoll == false)
				//{		
					cVector3f vImpulse;			
					/*if (sDeathAnim == "die_left")
						vImpulse = pCharBody.GetForward() * 1.f + pCharBody.GetRight() * 1.f;
					else if (sDeathAnim == "die_right")
						vImpulse = pCharBody.GetForward() * 1.f + pCharBody.GetRight() * -1.f;
					else*/
						//vImpulse = mBaseObj.GetCharBody().GetForward() * 1.f + mBaseObj.GetCharBody().GetRight() * 1.f;
					
					vImpulse = cVector3f(0, -1, 0);
					pKeyPickup.GetMainBody().AddImpulse(vImpulse);
				//}
			}
		}	
		
		//////////////////
		// Play sound
		mpStateMachine.AddTimer("PlayDeathSound", cMath_RandRectf(0.f, 0.1f));
	}

	//------------------------------------------------------------

	void State_Dead_Leave()
	{
		mlDead_HitboxBodyId = -1;
		mfDead_HitForce = 0.f;
		mfDead_HitMaxImpulse = 0.f;
		mvDead_HitPosition = cVector3f(0.f);
		mvDead_HitOrigin = cVector3f(0.f);
	}

	//------------------------------------------------------------

	void State_Dead_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Dead_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msDead_Anim != "" && !mbDead_AnimIsPose)
				Dead_ActivateDeathState();
		}
		return true;
	}
	
	//------------------------------------------------------------

	void State_Dead_TimerUp(uint64 alId)
	{
		if (H64("PlayDeathSound") == alId)
		{
			mBaseObj.PlaySound("Sound_Die", gsRatSound_Death, true, true);
		}
		else if (H64("Sleep") == alId)
		{
			mBaseObj.Sleep();
		}
		else if (H64("ActivateDeathState") == alId)
		{
			Dead_ActivateDeathState();
		}
		else if (H64("ActivateRagdoll") == alId)
		{
			SetRagdollActive(true, 0.5f);
		}
	}
	
	//------------------------------------------------------------
	
	void Dead_ActivateDeathState()
	{
		mBaseObj.StopAllAnimations(0.f);
		mBaseObj.SetEffectsActive(false, true);
	
		//////////////////
		// Get impulse dir
		cVector3f vDir = cMath_Vector3Normalize(mvDead_HitPosition - mvDead_HitOrigin);
		
		//////////////////
		// Add impulse to all ragdoll bodies		
		if (mlDead_HitboxBodyId == -1)
		{
			for (int i = 0; i < mBaseObj.GetHitboxBodyNum(); ++i)
				Dead_AddImpulseToRagdollBody(i, vDir);
		}
			
		//////////////////
		// Add impulse to specific ragdoll body
		else
		{
			Dead_AddImpulseToRagdollBody(mlDead_HitboxBodyId, vDir);
		}
	
		//////////////////
		// Sleep
		mpStateMachine.AddTimer("Sleep", 3.f);
	}
	
	//------------------------------------------------------------
	
	void Dead_AddImpulseToRagdollBody(int alBodyId, const cVector3f &in avDir)
	{
		iPhysicsBody@ pHitboxBody = mBaseObj.GetHitboxBody(alBodyId);
		iPhysicsBody@ pRagdollBody = pHitboxBody !is null ? mBaseObj.GetRagdollBodyFromHitboxName(pHitboxBody.GetName()) : null;
		
		if (pRagdollBody !is null)
		{
			cVector3f vImpulse = avDir * cMath_Min(mfDead_HitForce / pRagdollBody.GetMass(), mfDead_HitMaxImpulse);			
			pRagdollBody.AddImpulseAtPosition(vImpulse, mvDead_HitPosition);
		}
	}
	
	//------------------------------------------------------------

	//} END DEAD
	
	///////////////////////////////////
	// STATE: THREATENED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbThreatened_Backstep = false;
	float mfThreatened_ForcedBackstepTimer = 0.f;
	float mfThreatened_FearLevel = 0.f;
	
	//------------------------------------------------------------
	
	void State_Threatened_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Threatened ------");
		
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpPathfinder.Stop();
		mpMover.SetUseMoveStateAnimations(true);
		
		Threatened_TurnToThreatPosition();
		Threatened_KeepDistanceFromThreat();
		
		mpStateMachine.AddTimer("PlayScaredSound", cMath_RandRectf(0.1f, 0.3f));
	}
	
	//------------------------------------------------------------

	void State_Threatened_Leave()
	{
		mfThreatened_FearLevel = 0.f;
		mbThreatened_Backstep = false;
		mpMover.SetUseMoveStateAnimations(true);
		DestroyBackstepCollideShape();
	}
	
	//------------------------------------------------------------
	
	void State_Threatened_Update(float afTimeStep)
	{
        //Edit: made fear level increase 0
		float fFearLvlIncrease = 0.0f;
		
		////////////////////
		// Handle backstepping
		if (mbThreatened_Backstep || mfThreatened_ForcedBackstepTimer > 0.f)
		{
			///////////////////////////////////
			// Easier to scare away if cornered
			if (Backstep()==false)
				fFearLvlIncrease*=2.f;
			
			//////////////////
			// React to attack (TODO: Use a dedicated anim instead)
			if (mfThreatened_ForcedBackstepTimer > 0.f)
				mfThreatened_ForcedBackstepTimer -= afTimeStep;
		}
		
		////////////////////
		// Reduce fear increase based on distance
		float fDist = mBaseObj.GetDistanceToPlayer2D();
		float fT = 1.0f - ((fDist - gfRat_ThreatenedDistMin) / (gfRat_ThreatenedDistMax - gfRat_ThreatenedDistMin));
		
		fFearLvlIncrease *= cMath_Clamp(fT, 0.0f, 1.0f);
		
		///////////////////
		// Fear lvl incr
		mfThreatened_FearLevel += fFearLvlIncrease;
		
		///////////////////
		// if threatened for too long get more aggressive
		if (mfThreatened_FearLevel > 1.0f)
		{
            //DoctorD edit: probably something has to be modified here. Modified retreat to scared false 
			Blackboard_SetPlayerBlocksPath(mBaseObj, true); // Don't retreat past the player
			Retreat(eRatSpeed_Run, false, true);
            
			GameStats_IncreaseEntryAmount(eHeroStats_RatsScaredByTorch);
			return;
		}
		
		//cLux_AddDebugMessage("[Rat Agent] Threatened -> Fear Level: " + mfThreatened_FearLevel);
	}
	
	//------------------------------------------------------------
	
	bool State_Threatened_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_ThreatenedAttack)
		{
			Threatened_ReactToAttack();
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_Threatened_TimerUp(uint64 alId)
	{
		if (H64("TurnToThreatPosition") == alId)
		{
			Threatened_TurnToThreatPosition();
		}
		else if (H64("KeepDistanceFromThreat") == alId)
		{
			Threatened_KeepDistanceFromThreat();
		}
		if (H64("PlayScaredSound") == alId)
		{
			mBaseObj.PlaySound("Sound_Fear", gsRatSound_Fear, true, true);
		}
	}
	
	//------------------------------------------------------------
	
	void Threatened_PlayThreatenedAnim()
	{
		msAnimationState = "Threatened";
		mpMover.PlayAnimation(gsRatAnim_Alert, 0.3f, false);
	}
	
	//------------------------------------------------------------
	
	void Threatened_TurnToThreatPosition()
	{
		mpStateMachine.AddTimer("TurnToThreatPosition", cMath_RandRectf(0.5f, 1.0f));
		
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		if (vPlayerFeetPos.SqrLength() == 0.f)
			return;
		
		float fAngle = cMath_Vector3Angle(mBaseObj.GetPlayerDir(), mBaseObj.GetCharBody().GetForward());
		if (fAngle > 0.4f)
			mpMover.TurnToPos(vPlayerFeetPos);
	}
	
	//------------------------------------------------------------
	
	void Threatened_KeepDistanceFromThreat()
	{
		/////////
		// Repeat
		mpStateMachine.AddTimer("KeepDistanceFromThreat", cMath_RandRectf(0.1f, 0.6f));
		
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		float fDistToPlayerSqr = GetDistanceToPosSqr2D(vPlayerFeetPos);
		
		///////////////////
		// Is the player still threatening us?
		if (RatHandler_GetPlayerThreatensRats()==false)
		{
			if (Threatened_GetIsInReactionDistance())
				mpStateMachine.ChangeState(eRatState_Hunt);
			else
				GoToHole(true, tID_Invalid);
			
			return;
		}
		
		///////////////////////////
		// if within reaction range
		if (Threatened_GetIsInReactionDistance())
		{
			//////////////////////////////
			// If not in player view leave state
			if (Entity_IsInPlayerFOV(mBaseObj.GetName())==false) 
			{
				mpStateMachine.ChangeState(eRatState_Hunt);
				return;
			}
			
			//////////////
			// Stop moving
			if (mpPathfinder.IsMoving()) 
				mpPathfinder.Stop(); 
			
			////////////////////
			// If close backstep
			mbThreatened_Backstep = fDistToPlayerSqr < gfRat_ThreatenedBackstepDistMaxSqr;
		}
		////////////////////////////
		// if outside reaction range
		else
		{
			/////////////////////
			// if too far go back to prev state 
			// TODO: Check if rat was feeding in prior state instead of sending them all to feed.
			if (fDistToPlayerSqr > gfRat_ThreatenedDistMaxSqr)
				mpStateMachine.ChangeState(eRatState_FindFood);
			
			///////////////////////////
			// or move closer carefully
			if (mpPathfinder.IsMoving())
				return;
			
			mpPathfinder.MoveTo(vPlayerFeetPos, 1.f, false);
		}
	}
	
	//------------------------------------------------------------
	
	bool Threatened_GetIsInReactionDistance()
	{
		cVector3f vPlayerFeetPos = mBaseObj.GetPlayerFeetPos();
		float fDistToPlayerSqr = GetDistanceToPosSqr2D(vPlayerFeetPos);
		float fDistY = cMath_Abs(vPlayerFeetPos.y - mBaseObj.GetCharBody().GetFeetPosition().y);
		
		return (fDistToPlayerSqr < gfRat_ThreatenedDistMaxSqr && fDistY < 1.5f);
	}
	
	//------------------------------------------------------------
	
	void Threatened_ReactToAttack()
	{
		/////////////////////////
		// Should react? 
		if (Threatened_GetIsInReactionDistance()==false ||
			Entity_IsInPlayerFOV(mBaseObj.GetName())==false) 
			return;
		
		////////////
		// Increase fear
		float fDist = mBaseObj.GetDistanceToPlayer2D();
		float fT = 1.0f - ((fDist - gfRat_ThreatenedDistMin) / (gfRat_ThreatenedDistMax - gfRat_ThreatenedDistMin));
		
		float fIncrease = cMath_RandRectf(0.6f, 0.8f)*cMath_Clamp(fT, 0.0f, 1.0f);
		
		mfThreatened_FearLevel += fIncrease;
		
		////////////
		// Backstep
		mfThreatened_ForcedBackstepTimer = cMath_RandRectf(1.f, 2.f);
	}
	
	//------------------------------------------------------------
	
	//} END THREATENED
	
	///////////////////////////////////
	// STATE: WANDER THEN HIDE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbWanderThenHide_SensesActive = true;
	int mlWanderThenHide_HoleCheck = 3;
	
	//------------------------------------------------------------

	void State_WanderThenHide_Enter()
	{
		WanderThenHide_HideOrSelectNode();
		mlWanderThenHide_HoleCheck = 3;
	}

	//------------------------------------------------------------

	void State_WanderThenHide_Leave()
	{
	}

	//------------------------------------------------------------

	void State_WanderThenHide_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_WanderThenHide_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_EndOfPath ||
			alMessageId == eLuxEntityMessage_StuckCounterIsAtMax)
		{
			WanderThenHide_HideOrSelectNode();
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_WanderThenHide_TimerUp(uint64 alId)
	{
		if (H64("HideOrSelectNode") == alId)
			WanderThenHide_HideOrSelectNode();
	}
	
	//------------------------------------------------------------
	
	void WanderThenHide_HideOrSelectNode()
	{
		if (Entity_IsInPlayerFOV(mBaseObj.GetName())==false)
		{
			mBaseObj.SetActive(false);
			RatHandler_AddHidingRat(mBaseObj.GetID());
			return;
		}
		
		mlWanderThenHide_HoleCheck--;
		if (mlWanderThenHide_HoleCheck <= 0)
		{
			GoToHole(true, tID_Invalid);
			return;
		}
			
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition(), 0, 10.0f, false, true, false, null);
		if (pNode is null)
			mpStateMachine.AddTimer("HideOrSelectNode", 2.0f);
		else
			mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
	}
	
	//------------------------------------------------------------

	//} END WANDER THEN HIDE
	
	///////////////////////////////////
	// STATE: STALK PLAYER
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfStalkPlayer_MinDistSqr = gfRat_StalkPlayerMinDistSqr;
	float mfStalkPlayer_MaxDistSqr = gfRat_StalkPlayerMaxDistSqr;
	float mfStalkPlayer_FleeDistSqr = gfRat_StalkPlayerFleeDistSqr;
	float mfStalkPlayer_PrevDistSqr = 0;
	float mfStalkPlayer_AttackTimer = gfRat_StalkPlayerAttackTime;
	float mfStalkPlayer_FollowTimer = 0;
	tString msStalkPlayer_State = "";
	bool mbStalkPlayer_HasPlayedAlertSound = false;
	
	//------------------------------------------------------------

	void State_StalkPlayer_Enter()
	{		
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		msStalkPlayer_State = "";
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpStateMachine.AddTimer("EvaluateDistance", cMath_RandRectf(0.1, 0.2));
		
		mfStalkPlayer_AttackTimer = gfRat_StalkPlayerAttackTime;
		
		mfStalkPlayer_MinDistSqr = gfRat_StalkPlayerMinDistSqr;
		mfStalkPlayer_MaxDistSqr = gfRat_StalkPlayerMaxDistSqr;
		mfStalkPlayer_FleeDistSqr = gfRat_StalkPlayerFleeDistSqr;
		
		RatHandler_AddStalkingRat(mBaseObj.GetID());
		mbStalkPlayer_HasPlayedAlertSound = false;
		
		mBaseObj.SetCheckForDoors(true);
	}

	//------------------------------------------------------------

	void State_StalkPlayer_Leave()
	{
		mpMover.SetUseMoveStateAnimations(true);
		DestroyBackstepCollideShape();
		Blackboard_SetPlayerBlocksPath(mBaseObj, false);
		
		RatHandler_RemoveStalkingRat(mBaseObj.GetID());
		
		mBaseObj.SetCheckForDoors(false);
	}

	//------------------------------------------------------------

	void State_StalkPlayer_Update(float afTimeStep)
	{
		if (RatHandler_GetRatsAreAggressive() == false)
		{
			Retreat(eRatSpeed_Run, false, true);
			return;
		}
		
		if (msStalkPlayer_State == "Alert" || msStalkPlayer_State == "BackingOff")
		{
			float fDistSqr = (mBaseObj.GetPosition()-mBaseObj.GetPlayerFeetPos()).SqrLength();
			
			float fAttackTimeMul = 1.0f;
			int lStalkingRatCount = RatHandler_GetStalkingRatCount();
			int lAttackingRatCount = RatHandler_GetAttackingRatCount();
			bool bAttackAllowed = lStalkingRatCount >= glRat_StalkPlayerMinRatsBeforeAttack ||
								  lAttackingRatCount > 0;
			
			if (lStalkingRatCount >= glRat_StalkPlayerMinRatsBeforeAttack) 
				fAttackTimeMul *= 0.5f+((lStalkingRatCount-glRat_StalkPlayerMinRatsBeforeAttack)/5.0f)*3.0f;
				
			if (lAttackingRatCount > 0) fAttackTimeMul *= 5.0f;
			else if (fDistSqr < mfStalkPlayer_FleeDistSqr) fAttackTimeMul *= 3.0f;
			
			if (bAttackAllowed) mfStalkPlayer_AttackTimer -= afTimeStep * fAttackTimeMul;
			
			if (mfStalkPlayer_AttackTimer <= 0 )
			{
				mpStateMachine.ChangeState(eRatState_Hunt);
				return;
			}
			
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		}
		else
		{
			mfStalkPlayer_AttackTimer = gfRat_StalkPlayerAttackTime;
		}
		
		if (msStalkPlayer_State == "BackingOff")
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			Backstep(true);
		}
		
		if (msStalkPlayer_State == "Following")
		{
			mfStalkPlayer_FollowTimer -= afTimeStep;
			if (mfStalkPlayer_FollowTimer < 0)
			{
				mpStateMachine.ChangeState(eRatState_FindFood);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_StalkPlayer_Message(int alMessageId)
	{		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
		}
		return false;
	}
	
	//------------------------------------------------------------

	void State_StalkPlayer_TimerUp(uint64 alId)
	{
		if (H64("EvaluateDistance") == alId)
		{
			float fRepeatTimer = 0.5f;
			float fDistSqr = (mBaseObj.GetPosition()-mBaseObj.GetPlayerFeetPos()).SqrLength();
			bool bLineOfSight = mBaseObj.GetPlayerIsInLineOfSight();
			if (fDistSqr > mfStalkPlayer_MaxDistSqr || !bLineOfSight)
			{
				StalkPlayer_MoveToPlayer();
			}
			else if (fDistSqr < mfStalkPlayer_MinDistSqr)
			{
				if (msStalkPlayer_State == "Alert")
				{
					mpMover.SetUseMoveStateAnimations(true);
				}
		
				msStalkPlayer_State = "BackingOff";
				fRepeatTimer = cMath_RandRectf(0.1, 0.2);
			}
			else
			{
				if (msStalkPlayer_State != "Alert")
				{
					StalkPlayer_Alert();
				}
				
				fRepeatTimer = cMath_RandRectf(0.1, 0.2);
			}
			
			mpStateMachine.AddTimer("EvaluateDistance", fRepeatTimer);
		}
	}
	
	//------------------------------------------------------------
	
	void StalkPlayer_MoveToPlayer()
	{		
		float fRatAggressiveness = GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness);
		if (msStalkPlayer_State != "Following")
			mfStalkPlayer_FollowTimer = gfRat_StalkPlayerFollowTime * fRatAggressiveness;
			
		msStalkPlayer_State = "Following";
		
		mpMover.SetSpeedState(eRatSpeed_Walk);
		mpMover.SetUseMoveStateAnimations(true);
		
		float fTargetDist = cMath_Sqrt(cMath_RandRectf(mfStalkPlayer_MinDistSqr+0.75f, mfStalkPlayer_MaxDistSqr-0.75f));
		cVector3f vStart = mBaseObj.GetPlayerFeetPos()+cVector3f_Up*0.1;
		cVector3f vDir = cMath_Vector3Normalize(mBaseObj.GetPosition()-mBaseObj.GetPlayerFeetPos());
		
		float fRayDist;
		cVector3f vNrm;
		cLux_GetClosestBody(vStart, vDir, fTargetDist, fRayDist, vNrm);
		fRayDist -= mBaseObj.GetCharBody().GetSize().x*4;
		fRayDist = cMath_Clamp(fRayDist, 0, fTargetDist);
		
		cVector3f vTarget = vStart+vDir*fRayDist;
		
		mpPathfinder.MoveTo(vTarget, 1.0f, false);
	}
	
	//------------------------------------------------------------
	
	void StalkPlayer_Alert()
	{
		//mpMover.SetUseMoveStateAnimations(false);
		
		msStalkPlayer_State = "Alert";
		//mpMover.PlayAnimation(gsRatAnim_Warning, 0.3f, true);
		mpPathfinder.Stop();
	
		if (!mbStalkPlayer_HasPlayedAlertSound || Map_TimeHasPassed("RatAlertSound", 4.0f))
		{
			mBaseObj.PlaySound("Sound_Alert", gsRatSound_Alert, true, true);
			if (GameDifficulty_GetSettingValueByID_Float(eGameDifficultySetting_RatsAggressiveness) >= 1.0f)
				mBaseObj.GetMap().BroadcastSoundHeardEvent("RatScream", mBaseObj.GetPosition(), 15, 3, false, false);
			mbStalkPlayer_HasPlayedAlertSound = true;
		}
	}
	
	//------------------------------------------------------------

	//} END WANDER THEN HIDE
	
	//------------------------------------------------------------
	
	//} END RAT SPECIFIC CODE

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// PROPERTIES
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	cLuxCharMover@ mpMover;
	cLuxPathfinder@ mpPathfinder;
	cLuxStateMachine@ mpStateMachine;
	iCollideShape@ mpBackstepCollideShape = null;
	cLuxHeadTracker@ mpHeadTracker;
	
	bool mbSpawnAtPos = false; 
	
	int mlPathFindingResultFailCount = 0;
	bool mbAllowTrackBloodTrail = true;
	float mfSmellPlayerCount = 0.f;
	tString msAnimationState = "";
	
	float mfSmellFoodCount = 0.f;
	float mfHungerTimer = 0.0f;
	
	array<tID> mvIgnoredDamageAreas;
	
	bool mbAttracted_Enabled = true;
	cVector3f mvMeatAttractPos;
	
	tString msMovingToHoleState = "";
	tID m_idTargetHole = tID_Invalid;
	cVector3f mvTargetHolePos;
	cVector3f mvTargetHoleFeetPos;
	float mfEnterHoleTime = 0;
	
	tID m_idPrevClosestBloodTrail;
	
	bool mbLastHitByHeavyProp = false;
	
	bool mbPlayQuickTurnAnim = false;
	float mfQuickTurnCount = 0.f;
	int mlQuickTurnTimeStamp = 0;
	
	tString msHeadTracker_TargetEntity = "";
	tID m_idHeadTracker_TargetEntity = tID_Invalid;
	
	//------------------------------------------------------------

	//} END PROPERTIES

	//------------------------------------------------------------

	/////////////////////////////////////////
	// DEBUG
	//{//////////////////////////////////////

	//------------------------------------------------------------

	float DrawDebugOutput(cGuiSet@ apSet, iFontData@ apFont, float afStartY)
	{	
		//afStartY = cLux_DrawDebugText("--------- "+ mBaseObj.GetName() +" ---------", afStartY);	
		//afStartY = cLux_DrawDebugText("ground "+mBaseObj.GetCharBody().GravityIsActive(), afStartY);
		return afStartY;
	}

	//------------------------------------------------------------	
	
	
	void OnRenderSolid(cRendererCallbackFunctions@ apFunctions)
	{
		if (apFunctions is null) return;
		
		if (mpStateMachine.GetCurrentState() == eRatState_StalkPlayer)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), cMath_Sqrt(mfStalkPlayer_FleeDistSqr), cColor_Red*5);
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), cMath_Sqrt(mfStalkPlayer_MinDistSqr), cColor_Green*5);
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), cMath_Sqrt(mfStalkPlayer_MaxDistSqr), cColor_Blue*5);
		}
		
		//apFunctions.GetLowLevelGfx().DrawLine(mBaseObj.GetPosition(), mBaseObj.GetPosition()+cVector3f_Up*8, cColor_Green * 10.f);
	}
	
	//------------------------------------------------------------

	//} END DEBUG
}